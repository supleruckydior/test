-- 完整手动控制交易脚本 v2.2 (带拖动和关闭按钮)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer

-- 保留原始转义路径
local TradeRequest = ReplicatedStorage:FindFirstChild("\228\186\139\228\187\182")
    :FindFirstChild("\229\133\172\231\148\168")
    :FindFirstChild("\228\186\164\230\152\147")
    :FindFirstChild("\231\148\179\232\175\183\228\186\164\230\152\147")

local ConfirmTrade = ReplicatedStorage:FindFirstChild("\228\186\139\228\187\182")
    :FindFirstChild("\229\133\172\231\148\168")
    :FindFirstChild("\228\186\164\230\152\147")
    :FindFirstChild("\233\148\129\229\174\154\228\186\164\230\152\147")

-- 配置参数
local SETTINGS = {
    RequestInterval = 8,   -- 请求间隔（秒）
    ConfirmDelay = 2,      -- 确认延迟（秒）
    MaxRetries = 3,        -- 最大重试次数
    ResetInterval = 300,   -- 重置失败列表的间隔（秒，5分钟）
    RetryDelay = 60,       -- 失败后重试延迟（秒，1分钟）
    TradeTimeout = 15,     -- 交易超时时间（秒）
    IdleWaitTime = 30      -- 无目标时的等待时间（秒）
}

-- 状态控制
local isTrading = false
local tradedPlayers = {}  -- 已成功交易的玩家
local failedPlayers = {}  -- 交易失败的玩家（带时间戳，用于重试）
local currentPlayerIndex = 1  -- 当前玩家索引（用于顺序遍历）
local currentCoroutine = nil
local lastResetTime = tick()  -- 上次重置时间
local isProcessingTrade = false  -- 是否正在处理交易（防止重复请求）
local tradeStats = {  -- 交易统计
    success = 0,
    failed = 0,
    total = 0
}

-- 调试日志
local function debugLog(message)
    local timeStr = os.date("%H:%M:%S")
    print("[DEBUG]["..timeStr.."] "..message)
end

-- 打印玩家列表
local function printPlayerList()
    debugLog("=== 当前在线玩家列表 ===")
    for _, p in ipairs(Players:GetPlayers()) do
        debugLog(string.format("%s (ID: %d)%s", 
            p.Name, 
            p.UserId, 
            p == player and " <自己>" or ""
        ))
    end
    debugLog("========================")
end

-- 清理已离开的玩家
local function cleanupLeftPlayers()
    local currentPlayers = {}
    for _, p in ipairs(Players:GetPlayers()) do
        currentPlayers[p.UserId] = true
    end
    
    -- 从已交易列表中移除已离开的玩家
    local newTradedPlayers = {}
    for _, userId in ipairs(tradedPlayers) do
        if currentPlayers[userId] then
            table.insert(newTradedPlayers, userId)
        end
    end
    tradedPlayers = newTradedPlayers
    
    -- 从失败列表中移除已离开的玩家
    for userId, _ in pairs(failedPlayers) do
        if not currentPlayers[userId] then
            failedPlayers[userId] = nil
        end
    end
end

-- 获取有效玩家（排除自己和已成功交易的玩家）
local function getValidPlayers()
    local valid = {}
    local currentTime = tick()
    
    -- 清理已离开的玩家
    cleanupLeftPlayers()
    
    -- 清理过期的失败记录（超过重试延迟的可以重新尝试）
    for userId, failTime in pairs(failedPlayers) do
        if currentTime - failTime > SETTINGS.RetryDelay then
            failedPlayers[userId] = nil
        end
    end
    
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= player then
            local isTraded = table.find(tradedPlayers, p.UserId)
            local isFailed = failedPlayers[p.UserId]
            
            -- 如果未交易且（未失败或失败时间已过），则加入候选列表
            if not isTraded and (not isFailed or (currentTime - isFailed > SETTINGS.RetryDelay)) then
                table.insert(valid, p)
            end
        end
    end
    return valid
end

-- 安全交易流程
local function safeTrade(target)
    -- 防止重复请求
    if isProcessingTrade then
        debugLog("正在处理其他交易，跳过")
        return false
    end
    
    -- 检查玩家是否还在线
    if not target.Parent then
        debugLog("目标玩家已离开: "..target.Name)
        return false
    end
    
    isProcessingTrade = true
    tradeStats.total = tradeStats.total + 1
    debugLog("开始与 "..target.Name.." 交易")
    
    local success = false
    for retry = 1, SETTINGS.MaxRetries do
        -- 再次检查玩家是否在线
        if not target.Parent then
            debugLog("交易过程中玩家离开: "..target.Name)
            break
        end
        
        -- 发送请求
        local success1, err1 = pcall(function()
            TradeRequest:FireServer(target)
            debugLog("请求发送成功 (重试 "..retry.."/"..SETTINGS.MaxRetries..")")
            return true
        end)
        
        if not success1 then
            debugLog("请求失败: "..err1)
            task.wait(2)
            continue
        end

        -- 等待交易界面并确认交易
        local success2, err2 = pcall(function()
            -- 等待交易界面可见
            local maxWaitTime = SETTINGS.TradeTimeout
            local startTime = tick()
            local tradeUI = game:GetService("Players").LocalPlayer.PlayerGui.GUI["\228\186\140\231\186\167\231\149\140\233\157\162"]["\228\186\164\230\152\147"]
            
            while not tradeUI.Visible and (tick() - startTime) < maxWaitTime do
                task.wait(0.1)
                -- 检查是否还在交易状态
                if not isTrading then
                    error("交易已停止")
                end
            end
            
            if not tradeUI.Visible then
                error("交易界面未在"..maxWaitTime.."秒内显示")
            end
            
            -- 等待一小段时间确保界面完全加载
            task.wait(0.5)
            
            ConfirmTrade:FireServer(true)
            debugLog("确认发送成功")
            
            -- 只有确认发送成功后才标记为已交易
            table.insert(tradedPlayers, target.UserId)
            -- 如果之前在失败列表中，移除它
            failedPlayers[target.UserId] = nil
            tradeStats.success = tradeStats.success + 1
            success = true
            return true
        end)

        if success2 then 
            break
        end
        
        debugLog("确认失败: "..err2)
        task.wait(1)
    end
    
    isProcessingTrade = false
    
    if not success then
        -- 所有重试都失败，记录失败时间
        failedPlayers[target.UserId] = tick()
        tradeStats.failed = tradeStats.failed + 1
        debugLog("与 "..target.Name.." 交易失败，将在 "..SETTINGS.RetryDelay.." 秒后重试")
    end
    
    return success
end

-- 主交易循环
local function tradeLoop()
    debugLog("交易循环启动")
    
    while isTrading do
        -- 定期重置失败列表（避免永久标记失败玩家）
        local currentTime = tick()
        if currentTime - lastResetTime > SETTINGS.ResetInterval then
            debugLog("重置失败玩家列表（已过 "..SETTINGS.ResetInterval.." 秒）")
            failedPlayers = {}
            lastResetTime = currentTime
        end
        
        printPlayerList()
        local candidates = getValidPlayers()
        
        if #candidates > 0 then
            -- 使用顺序遍历而不是随机选择，确保每个玩家都被尝试
            -- 如果索引超出范围，重置为1
            if currentPlayerIndex > #candidates then
                currentPlayerIndex = 1
            end
            
            local target = candidates[currentPlayerIndex]
            debugLog("选中目标: "..target.Name.." ("..currentPlayerIndex.."/"..#candidates..")")
            
            if safeTrade(target) then
                debugLog("与 "..target.Name.." 交易成功")
            else
                debugLog("与 "..target.Name.." 交易失败")
            end
            
            -- 移动到下一个玩家
            currentPlayerIndex = currentPlayerIndex + 1
            
            -- 如果已经遍历完所有玩家，重置索引
            if currentPlayerIndex > #candidates then
                currentPlayerIndex = 1
                debugLog("已完成一轮遍历，等待新玩家或重试失败玩家")
            end
            
            -- 正常等待间隔
            for i = 1, SETTINGS.RequestInterval do
                if not isTrading then break end
                task.wait(1)
            end
        else
            local failedCount = 0
            for _ in pairs(failedPlayers) do
                failedCount = failedCount + 1
            end
            debugLog("没有可交易目标（已交易: "..#tradedPlayers..", 失败: "..failedCount..", 成功: "..tradeStats.success..", 失败: "..tradeStats.failed.."）")
            -- 如果没有可交易目标，重置索引并等待更长时间
            currentPlayerIndex = 1
            
            -- 如果所有玩家都交易过了，等待更长时间
            if #tradedPlayers > 0 and #getValidPlayers() == 0 then
                debugLog("所有玩家已处理，等待 "..SETTINGS.IdleWaitTime.." 秒...")
                for i = 1, SETTINGS.IdleWaitTime do
                    if not isTrading then break end
                    task.wait(1)
                end
            else
                -- 可中断等待
                for i = 1, SETTINGS.RequestInterval do
                    if not isTrading then break end
                    task.wait(1)
                end
            end
        end
    end
    debugLog("交易循环终止")
end

-- 创建UI界面
local function createControlPanel()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "TradeControlPanel"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = player:WaitForChild("PlayerGui")

    -- 主框架（增加高度以适应内容）
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 240, 0, 180)  -- 高度增加到180以显示统计信息
    frame.Position = UDim2.new(1, -250, 1, -190) -- 右下角位置
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    frame.BorderSizePixel = 0
    frame.Parent = screenGui

    -- 标题栏（用于拖动）
    local titleBar = Instance.new("Frame")
    titleBar.Size = UDim2.new(1, 0, 0, 25)  -- 高度增加到25
    titleBar.Position = UDim2.new(0, 0, 0, 0)
    titleBar.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    titleBar.BorderSizePixel = 0
    titleBar.Active = true
    titleBar.Parent = frame

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(0.8, 0, 1, 0)
    titleLabel.Position = UDim2.new(0.05, 0, 0, 0)
    titleLabel.Text = "自动交易控制面板"
    titleLabel.TextColor3 = Color3.new(1,1,1)
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.BackgroundTransparency = 1
    titleLabel.Parent = titleBar

    -- 关闭按钮
    local closeButton = Instance.new("TextButton")
    closeButton.Size = UDim2.new(0.15, 0, 0.8, 0)
    closeButton.Position = UDim2.new(0.85, 0, 0.1, 0)
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.new(1,1,1)
    closeButton.BackgroundColor3 = Color3.fromRGB(80, 0, 0)
    closeButton.Parent = titleBar

    -- 控制按钮
    local toggleBtn = Instance.new("TextButton")
    toggleBtn.Size = UDim2.new(0.9, 0, 0.3, 0)
    toggleBtn.Position = UDim2.new(0.05, 0, 0.25, 0)
    toggleBtn.Text = "▶ 启动自动交易"
    toggleBtn.TextColor3 = Color3.new(1,1,1)
    toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    toggleBtn.Parent = frame

    -- 状态显示
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(0.9, 0, 0.2, 0)
    statusLabel.Position = UDim2.new(0.05, 0, 0.45, 0)
    statusLabel.Text = "状态：未启动"
    statusLabel.TextColor3 = Color3.new(0.9,0.9,0.9)
    statusLabel.BackgroundTransparency = 1
    statusLabel.TextSize = 12
    statusLabel.Parent = frame

    -- 玩家计数
    local countLabel = Instance.new("TextLabel")
    countLabel.Size = UDim2.new(0.9, 0, 0.15, 0)
    countLabel.Position = UDim2.new(0.05, 0, 0.65, 0)
    countLabel.Text = "可交易玩家：0"
    countLabel.TextColor3 = Color3.new(0.7,0.7,0.7)
    countLabel.BackgroundTransparency = 1
    countLabel.TextSize = 12
    countLabel.Parent = frame
    
    -- 统计信息
    local statsLabel = Instance.new("TextLabel")
    statsLabel.Size = UDim2.new(0.9, 0, 0.25, 0)
    statsLabel.Position = UDim2.new(0.05, 0, 0.8, 0)
    statsLabel.Text = "成功: 0 | 失败: 0"
    statsLabel.TextColor3 = Color3.new(0.6,0.8,0.6)
    statsLabel.BackgroundTransparency = 1
    statsLabel.TextSize = 11
    statsLabel.Parent = frame

    -- 拖动功能
    local dragging = false
    local dragStart, startPos

    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
        end
    end)

    titleBar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and dragging then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
        end
    end)

    -- 关闭按钮事件
    closeButton.MouseButton1Click:Connect(function()
        screenGui:Destroy()
        debugLog("控制面板已关闭")
        
        -- 如果正在交易则停止
        if isTrading then
            isTrading = false
            if currentCoroutine then
                coroutine.close(currentCoroutine)
                debugLog("交易已停止")
            end
        end
    end)

    -- 控制按钮事件
    toggleBtn.MouseButton1Click:Connect(function()
        isTrading = not isTrading
        toggleBtn.Text = isTrading and "⏹ 停止交易" or "▶ 启动交易"
        statusLabel.Text = "状态："..(isTrading and "运行中" or "已停止")
        
        if isTrading then
            tradedPlayers = {}
            failedPlayers = {}
            currentPlayerIndex = 1
            lastResetTime = tick()
            isProcessingTrade = false
            tradeStats = { success = 0, failed = 0, total = 0 }
            debugLog("手动启动交易（已重置所有列表和统计）")
            currentCoroutine = coroutine.create(tradeLoop)
            coroutine.resume(currentCoroutine)
        else
            if currentCoroutine then
                coroutine.close(currentCoroutine)
                debugLog("手动终止交易")
            end
        end
    end)

    -- 实时更新玩家计数和统计
    game:GetService("RunService").Heartbeat:Connect(function()
        countLabel.Text = "可交易玩家："..#getValidPlayers()
        statsLabel.Text = string.format("成功: %d | 失败: %d | 总计: %d", 
            tradeStats.success, 
            tradeStats.failed, 
            tradeStats.total)
    end)
end

-- 初始化验证
debugLog("==== 系统初始化 ====")
debugLog("交易请求事件: "..tostring(TradeRequest ~= nil))
debugLog("确认交易事件: "..tostring(ConfirmTrade ~= nil))
printPlayerList()

-- 创建控制面板
createControlPanel()
debugLog("控制面板已加载")

