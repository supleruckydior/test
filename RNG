if not game:IsLoaded() then
    game.Loaded:Wait()
end
local player = game:GetService("Players").LocalPlayer
local SoundService = game:GetService("SoundService")
local RunService = game:GetService("RunService")

-- [1] Mute all existing sounds (including those not parented to SoundService)
for _, sound in pairs(SoundService:GetDescendants()) do
    if sound:IsA("Sound") then
        pcall(function()
            sound.Volume = 0
            sound.Playing = false
        end)
    end
end
-- [4] Continuous sound killer (catches any new sounds)
RunService.Heartbeat:Connect(function()
    for _, sound in pairs(SoundService:GetDescendants()) do
        if sound:IsA("Sound") then
            pcall(function()
                sound.Volume = 0
                sound.Playing = false
            end)
        end
    end
end)

print("ğŸ”‡ ALL SOUNDS PERMANENTLY MUTED!")
-- ========== JSONè®¾ç½®ä¿å­˜åŠŸèƒ½ ==========
local HttpService = game:GetService("HttpService")
local settingsFileName = "BossMonitorSettings.json"

-- è‡ªåŠ¨è·å–æ‰€æœ‰åŒºåŸŸID
local function getAvailableAreaIds()
    local areaIds = {}
    local success, basePath = pcall(function()
        return workspace.AreaModel["101"].Area["101_CommonGui"]
    end)
    
    if success and basePath then
        for _, child in ipairs(basePath:GetChildren()) do
            local areaId = string.match(child.Name, "ArenaSoloShower_(%d+)")
            if areaId then
                table.insert(areaIds, tonumber(areaId))
            end
        end
    end
    
    table.sort(areaIds)
    return areaIds
end

-- æ ¹æ®æ‰¾åˆ°çš„åŒºåŸŸIDåˆ›å»ºé»˜è®¤è®¾ç½®
local function createDefaultSettings(areaIds)
    local defaultAreaConfig = {}
    local defaultLingShouConfig = {}
    
    for _, areaId in ipairs(areaIds) do
        defaultAreaConfig[areaId] = false
        defaultLingShouConfig[areaId] = false
    end
    
    return {
        areaConfig = defaultAreaConfig,
        lingShouAreaConfig = defaultLingShouConfig,
        windowPosition = {x = 0.5, y = 0.5},
        isCollapsed = false,
        autoReconnect = false
    }
end

-- å°è¯•åŠ è½½è®¾ç½®
local function loadSettings(areaIds)
    local success, loadedSettings = pcall(function()
        if not isfolder("BossMonitor") then
            makefolder("BossMonitor")
        end
        
        local filePath = "BossMonitor/"..settingsFileName
        if not isfile(filePath) then
            return createDefaultSettings(areaIds)
        end
        
        local fileContent = readfile(filePath)
        return HttpService:JSONDecode(fileContent)
    end)
    
    if success and loadedSettings then
        -- ä¿®å¤é”®ç±»å‹é—®é¢˜ï¼šå°†å­—ç¬¦ä¸²é”®è½¬æ¢ä¸ºæ•°å­—é”®
        local function fixKeyTypes(configTable)
            local fixed = {}
            for k, v in pairs(configTable) do
                fixed[tonumber(k) or k] = v
            end
            return fixed
        end
        
        -- ç¡®ä¿æ‰€æœ‰é…ç½®è¡¨éƒ½å­˜åœ¨
        loadedSettings.areaConfig = loadedSettings.areaConfig or {}
        loadedSettings.lingShouAreaConfig = loadedSettings.lingShouAreaConfig or {}
        
        -- ä¿®å¤é”®ç±»å‹
        loadedSettings.areaConfig = fixKeyTypes(loadedSettings.areaConfig)
        loadedSettings.lingShouAreaConfig = fixKeyTypes(loadedSettings.lingShouAreaConfig)
        
        -- åˆå¹¶æ–°å‘ç°çš„åŒºåŸŸ
        for _, areaId in ipairs(areaIds) do
            if loadedSettings.areaConfig[areaId] == nil then
                loadedSettings.areaConfig[areaId] = false
            end
            if loadedSettings.lingShouAreaConfig[areaId] == nil then
                loadedSettings.lingShouAreaConfig[areaId] = false
            end
        end
        
        -- ç§»é™¤ä¸å†å­˜åœ¨çš„åŒºåŸŸ
        for areaId in pairs(loadedSettings.areaConfig) do
            if not table.find(areaIds, areaId) then
                loadedSettings.areaConfig[areaId] = nil
            end
        end
        for areaId in pairs(loadedSettings.lingShouAreaConfig) do
            if not table.find(areaIds, areaId) then
                loadedSettings.lingShouAreaConfig[areaId] = nil
            end
        end
        
        return loadedSettings
    else
        return createDefaultSettings(areaIds)
    end
end

-- ä¿å­˜è®¾ç½®
local function saveSettings(settings)
    local success, err = pcall(function()
        if not isfolder("BossMonitor") then
            makefolder("BossMonitor")
        end
        
        local filePath = "BossMonitor/"..settingsFileName
        local json = HttpService:JSONEncode(settings)
        writefile(filePath, json)
    end)
    
    if not success then
        warn("ä¿å­˜è®¾ç½®å¤±è´¥:", err)
    end
end

-- è·å–æ‰€æœ‰å¯ç”¨çš„åŒºåŸŸID
local availableAreaIds = getAvailableAreaIds()
if #availableAreaIds == 0 then
    warn("æœªæ‰¾åˆ°ä»»ä½•BOSSåŒºåŸŸï¼Œè„šæœ¬å°†åœæ­¢")
    return
end

-- åŠ è½½è®¾ç½®
local settings = loadSettings(availableAreaIds)
local areaConfig = settings.areaConfig
local lingShouAreaConfig = settings.lingShouAreaConfig

-- ========== è‡ªåŠ¨æ›´æ–°æ€ªç‰©è·¯å¾„ ==========
local function getMonsterPaths()
    local monsterPaths = {}
    local success, basePath = pcall(function()
        return workspace.AreaModel["101"].Area["101_CommonGui"]
    end)
    
    if not success or not basePath then
        warn("æ— æ³•æ‰¾åˆ°åŸºç¡€è·¯å¾„ workspace.AreaModel['101'].Area['101_CommonGui']")
        return monsterPaths
    end
    
    -- æŸ¥æ‰¾æ‰€æœ‰ArenaSoloShowerå®ä¾‹
    for _, areaId in ipairs(availableAreaIds) do
        local childName = "ArenaSoloShower_"..areaId
        local child = basePath:FindFirstChild(childName)
        if child then
            monsterPaths[areaId] = {
                path = child,
                guiAth = child:FindFirstChild("GuiAth")
            }
        end
    end
    
    return monsterPaths
end

-- åˆå§‹è·å–è·¯å¾„
local monsterPaths = getMonsterPaths()

-- ========== ç¾è§‚çš„GUIç•Œé¢ ==========
local gui = Instance.new("ScreenGui")
gui.Name = "BossCDMonitor"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- ä¸»æ¡†æ¶
local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 350, 0, 550)
frame.Position = UDim2.new(settings.windowPosition.x, -175, settings.windowPosition.y, -275)
frame.BackgroundColor3 = Color3.fromRGB(36, 36, 42)
frame.BackgroundTransparency = 0.2
frame.BorderSizePixel = 0
frame.Active = true
frame.Selectable = true
frame.Parent = gui

-- æ·»åŠ åœ†è§’
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 8)
corner.Parent = frame

-- æ·»åŠ é˜´å½±
local shadow = Instance.new("ImageLabel")
shadow.Name = "Shadow"
shadow.Image = "rbxassetid://1316045217"
shadow.ImageColor3 = Color3.new(0, 0, 0)
shadow.ImageTransparency = 0.8
shadow.ScaleType = Enum.ScaleType.Slice
shadow.SliceCenter = Rect.new(10, 10, 118, 118)
shadow.Size = UDim2.new(1, 20, 1, 20)
shadow.Position = UDim2.new(0, -10, 0, -10)
shadow.BackgroundTransparency = 1
shadow.ZIndex = -1
shadow.Parent = frame

-- æ ‡é¢˜æ 
local titleBar = Instance.new("Frame")
titleBar.Size = UDim2.new(1, 0, 0, 40)
titleBar.Position = UDim2.new(0, 0, 0, 0)
titleBar.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
titleBar.BorderSizePixel = 0
titleBar.Parent = frame

local titleCorner = Instance.new("UICorner")
titleCorner.CornerRadius = UDim.new(0, 8)
titleCorner.Parent = titleBar

local title = Instance.new("TextLabel")
title.Text = "BOSSç›‘æ§ç³»ç»Ÿ v3.5.3"
title.Size = UDim2.new(0.7, 0, 1, 0)
title.Position = UDim2.new(0.15, 0, 0, 0)
title.BackgroundTransparency = 1
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.GothamBold
title.TextSize = 16
title.Parent = titleBar

-- æŠ˜å æŒ‰é’®
local toggleButton = Instance.new("TextButton")
toggleButton.Text = settings.isCollapsed and "â–²" or "â–¼"
toggleButton.Size = UDim2.new(0, 30, 0, 30)
toggleButton.Position = UDim2.new(1, -35, 0.5, -15)
toggleButton.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.Font = Enum.Font.Gotham
toggleButton.TextSize = 14
toggleButton.Parent = titleBar

local toggleCorner = Instance.new("UICorner")
toggleCorner.CornerRadius = UDim.new(0, 6)
toggleCorner.Parent = toggleButton

-- å†…å®¹åŒºåŸŸ
local contentFrame = Instance.new("Frame")
contentFrame.Size = UDim2.new(1, -20, 1, -70)
contentFrame.Position = UDim2.new(0, 10, 0, 50)
contentFrame.BackgroundTransparency = 1
contentFrame.ClipsDescendants = true
contentFrame.Visible = not settings.isCollapsed
contentFrame.Parent = frame

-- åŒºåŸŸæ ‡ç­¾
local areaLabel = Instance.new("TextLabel")
areaLabel.Text = "BOSSåŒºåŸŸç›‘æ§"
areaLabel.Size = UDim2.new(1, 0, 0, 25)
areaLabel.Position = UDim2.new(0, 0, 0, 0)
areaLabel.BackgroundTransparency = 1
areaLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
areaLabel.Font = Enum.Font.Gotham
areaLabel.TextSize = 14
areaLabel.TextXAlignment = Enum.TextXAlignment.Left
areaLabel.Parent = contentFrame

-- åŒºåŸŸæŒ‰é’®å®¹å™¨
local areaButtons = Instance.new("ScrollingFrame")
areaButtons.Size = UDim2.new(1, 0, 0, 150)
areaButtons.Position = UDim2.new(0, 0, 0, 25)
areaButtons.BackgroundTransparency = 1
areaButtons.ScrollBarThickness = 5
areaButtons.CanvasSize = UDim2.new(0, 0, 0, math.ceil(#availableAreaIds/4)*35)
areaButtons.Parent = contentFrame

-- çµå…½æ ‡ç­¾
local lsLabel = Instance.new("TextLabel")
lsLabel.Text = "çµå…½æ•æ‰è®¾ç½®"
lsLabel.Size = UDim2.new(1, 0, 0, 25)
lsLabel.Position = UDim2.new(0, 0, 0, 185)
lsLabel.BackgroundTransparency = 1
lsLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
lsLabel.Font = Enum.Font.Gotham
lsLabel.TextSize = 14
lsLabel.TextXAlignment = Enum.TextXAlignment.Left
lsLabel.Parent = contentFrame

-- çµå…½æŒ‰é’®å®¹å™¨
local lsButtonsFrame = Instance.new("ScrollingFrame")
lsButtonsFrame.Size = UDim2.new(1, 0, 0, 150)
lsButtonsFrame.Parent = contentFrame
lsButtonsFrame.Position = UDim2.new(0, 0, 0, 210)
lsButtonsFrame.BackgroundTransparency = 1
lsButtonsFrame.ScrollBarThickness = 5
lsButtonsFrame.CanvasSize = UDim2.new(0, 0, 0, math.ceil(#availableAreaIds/4)*35)

-- åˆ›å»ºæ¼‚äº®çš„æŒ‰é’®
local function createButton(text, parent, defaultColor, activeColor)
    local button = Instance.new("TextButton")
    button.Text = text
    button.Size = UDim2.new(0.23, 0, 0, 28)
    button.BackgroundColor3 = defaultColor
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Font = Enum.Font.Gotham
    button.TextSize = 12
    button.AutoButtonColor = false
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = button
    
    local stroke = Instance.new("UIStroke")
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    stroke.Color = Color3.fromRGB(80, 80, 80)
    stroke.Thickness = 1
    stroke.Parent = button
    
    button.Parent = parent
    
    -- æ‚¬åœæ•ˆæœ
    button.MouseEnter:Connect(function()
        local targetColor = button.BackgroundColor3 == activeColor and activeColor or 
                          Color3.fromRGB(
                              math.floor(defaultColor.R * 255 + 20),
                              math.floor(defaultColor.G * 255 + 20),
                              math.floor(defaultColor.B * 255 + 20)
                          )
        game:GetService("TweenService"):Create(
            button,
            TweenInfo.new(0.2),
            {BackgroundColor3 = targetColor}
        ):Play()
    end)
    
    button.MouseLeave:Connect(function()
        local targetColor = button.BackgroundColor3 == activeColor and activeColor or defaultColor
        game:GetService("TweenService"):Create(
            button,
            TweenInfo.new(0.2),
            {BackgroundColor3 = targetColor}
        ):Play()
    end)
    
    return button
end

-- åŒºåŸŸåç§°æ˜ å°„
local areaNames = {
    [100] = "åŒºåŸŸ1é‡çŒª",
    [101] = "åŒºåŸŸ2ç†ŠçŒ«",
    [102] = "åŒºåŸŸ3ç™½ç‹¼",
    [103] = "åŒºåŸŸ4çŒ›çŠ¸",
    [104] = "åŒºåŸŸ5ç™½è™",
    [105] = "åŒºåŸŸ6é•¿è€é¾™",
    [106] = "åŒºåŸŸ7è¿œå¤é¾™"
}

-- çµå…½åç§°æ˜ å°„
local petNames = {
    [100] = "çµå…½1é‡çŒª",
    [101] = "çµå…½2ç†ŠçŒ«",
    [102] = "çµå…½3ç™½ç‹¼",
    [103] = "çµå…½4çŒ›çŠ¸",
    [104] = "çµå…½5ç™½è™",
    [105] = "çµå…½6é•¿è€é¾™",
    [106] = "çµå…½7è¿œå¤é¾™"
}

-- åˆ›å»ºæŒ‰é’®çŠ¶æ€æ›´æ–°å‡½æ•°
local function updateButtonState(button, isActive, name, activeColor, defaultColor)
    if isActive then
        button.Text = name..":ON"
        button.BackgroundColor3 = activeColor
    else
        button.Text = name
        button.BackgroundColor3 = defaultColor
    end
end

-- åˆ›å»ºBOSSç›‘æ§æŒ‰é’®
for i, areaId in ipairs(availableAreaIds) do
    local row = math.floor((i-1)/4)
    local col = (i-1) % 4
    
    -- è·å–åŒºåŸŸåç§°ï¼Œå¦‚æœæ²¡æœ‰é¢„è®¾åˆ™ä½¿ç”¨é»˜è®¤
    local areaName = areaNames[areaId] or ("åŒºåŸŸ"..areaId)
    local petName = petNames[areaId] or ("çµå…½"..areaId)
    
    -- Bossç›‘æ§æŒ‰é’®
    local bossBtn = createButton(
        areaConfig[areaId] and (areaName..":ON") or areaName,
        areaButtons,
        areaConfig[areaId] and Color3.fromRGB(40, 80, 40) or Color3.fromRGB(80, 40, 40),
        Color3.fromRGB(40, 80, 40)
    )
    bossBtn.Position = UDim2.new(col * 0.25 + 0.025, 0, 0, row * 35)
    
    bossBtn.MouseButton1Click:Connect(function()
        areaConfig[areaId] = not areaConfig[areaId]
        updateButtonState(bossBtn, areaConfig[areaId], areaName, Color3.fromRGB(40, 80, 40), Color3.fromRGB(80, 40, 40))
        settings.areaConfig = areaConfig
        saveSettings(settings)
    end)
    
    -- çµå…½æ•æ‰æŒ‰é’®
    local isActive = lingShouAreaConfig[areaId]
    local defaultColor = isActive and Color3.fromRGB(40, 80, 40) or Color3.fromRGB(40, 40, 80)
    
    local lsBtn = createButton(petName, lsButtonsFrame, defaultColor, Color3.fromRGB(40, 80, 40))
    lsBtn.Position = UDim2.new(col * 0.25 + 0.025, 0, 0, row * 35)
    updateButtonState(lsBtn, isActive, petName, Color3.fromRGB(40, 80, 40), Color3.fromRGB(40, 40, 80))
    
    lsBtn.MouseButton1Click:Connect(function()
        lingShouAreaConfig[areaId] = not lingShouAreaConfig[areaId]
        settings.lingShouAreaConfig = lingShouAreaConfig
        updateButtonState(lsBtn, lingShouAreaConfig[areaId], petName, Color3.fromRGB(40, 80, 40), Color3.fromRGB(40, 40, 80))
        saveSettings(settings)
    end)
end

-- è‡ªåŠ¨é‡è¿æŒ‰é’®
local autoReconnectBtn = createButton("è‡ªåŠ¨é‡è¿: "..(settings.autoReconnect and "ON" or "OFF"), contentFrame, 
                                   settings.autoReconnect and Color3.fromRGB(40, 80, 40) or Color3.fromRGB(80, 40, 40),
                                   Color3.fromRGB(40, 80, 40))
autoReconnectBtn.Size = UDim2.new(1, 0, 0, 36)
autoReconnectBtn.Position = UDim2.new(0, 0, 0, 370)
autoReconnectBtn.Text = "è‡ªåŠ¨é‡è¿ (30åˆ†é’Ÿ): "..(settings.autoReconnect and "ON" or "OFF")

autoReconnectBtn.MouseButton1Click:Connect(function()
    settings.autoReconnect = not settings.autoReconnect
    autoReconnectBtn.Text = "è‡ªåŠ¨é‡è¿ (30åˆ†é’Ÿ): "..(settings.autoReconnect and "ON" or "OFF")
    autoReconnectBtn.BackgroundColor3 = settings.autoReconnect and Color3.fromRGB(40, 80, 40) or Color3.fromRGB(80, 40, 40)
    saveSettings(settings)
    
    if settings.autoReconnect then
        print("è‡ªåŠ¨é‡è¿å·²å¯ç”¨ï¼Œå°†åœ¨30åˆ†é’Ÿåæ‰§è¡Œ")
    else
        print("è‡ªåŠ¨é‡è¿å·²ç¦ç”¨")
    end
end)

-- åœæ­¢æŒ‰é’®
local stopBtn = createButton("åœæ­¢æ‰€æœ‰ç›‘æ§", contentFrame, Color3.fromRGB(180, 50, 50), Color3.fromRGB(150, 30, 30))
stopBtn.Size = UDim2.new(1, 0, 0, 36)
stopBtn.Position = UDim2.new(0, 0, 0, 410)

-- æŠ˜å åŠŸèƒ½
local collapsibleElements = {contentFrame}
local isCollapsed = settings.isCollapsed

local function toggleCollapse()
    isCollapsed = not isCollapsed
    
    if isCollapsed then
        toggleButton.Text = "â–²"
        frame.Size = UDim2.new(0, 350, 0, 40)
        for _, element in ipairs(collapsibleElements) do
            element.Visible = false
        end
    else
        toggleButton.Text = "â–¼"
        frame.Size = UDim2.new(0, 350, 0, 550)
        for _, element in ipairs(collapsibleElements) do
            element.Visible = true
        end
    end
    
    settings.isCollapsed = isCollapsed
    saveSettings(settings)
end

toggleButton.MouseButton1Click:Connect(toggleCollapse)

-- æ‹–åŠ¨åŠŸèƒ½
local UserInputService = game:GetService("UserInputService")
local dragging = false
local dragStart = Vector2.new(0, 0)
local startPos = frame.Position

local function saveWindowPosition()
    settings.windowPosition = {
        x = frame.Position.X.Scale,
        y = frame.Position.Y.Scale
    }
    saveSettings(settings)
end

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = frame.Position
    end
end)

titleBar.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
        saveWindowPosition()
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement and dragging then
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
    end
end)

gui.Parent = player:WaitForChild("PlayerGui")

-- ========== æ ¸å¿ƒåŠŸèƒ½ ==========
local running = true
local currentFloatTask = nil
local currentCircleTask = nil
local currentCenterPosition = nil
local hasEnteredBattle = false
local targetPosition = Vector3.new(-70, 18, -62)
local reconnectTimer = nil
local lastReconnectTime = 0

-- å®‰å…¨è·å–å¯¹è±¡
local function safeGet(path)
    local current = game
    for _, part in ipairs(path) do
        local success, child = pcall(function() return current[part] end)
        if not success or not child then
            return nil
        end
        current = child
    end
    return current
end

-- æˆ˜æ–—çŠ¶æ€æ£€æµ‹
local function isWaitClearVisible()
    local waitFrame = safeGet({
        "Players", player.Name, 
        "PlayerGui", "MainGui", 
        "ScreenGui", "ArenaStatusView", 
        "ResultFrame"
    })
    return waitFrame and waitFrame:IsA("Frame") and waitFrame.Visible
end

local function isInBattle()
    local arenaView = safeGet({
        "Players", player.Name,
        "PlayerGui", "MainGui",
        "ScreenGui", "ArenaStatusView"
    })
    return arenaView and arenaView:IsA("Frame")
end

-- è·å–è§†è§’å‰æ–¹ä½ç½®
local function getViewForwardCenter()
    local Character = player.Character
    if not Character then return nil end
    
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return nil end

    local camera = workspace.CurrentCamera
    if camera then
        local cameraCF = camera.CFrame
        return Vector3.new(
            cameraCF.Position.X + cameraCF.LookVector.X * 100,
            HumanoidRootPart.Position.Y,
            cameraCF.Position.Z + cameraCF.LookVector.Z * 100
        )
    end
    return HumanoidRootPart.Position
end

-- åœ†å½¢ç§»åŠ¨
local function startCircleMovement()
    if currentCircleTask then
        currentCircleTask:Disconnect()
        currentCircleTask = nil
    end

    local Character = player.Character
    if not Character then return end
    
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then return end

    local radius = 50
    local angle = 0
    local speed = 0.013
    
    currentCircleTask = game:GetService("RunService").Heartbeat:Connect(function(dt)
        if not running or not currentCenterPosition or not HumanoidRootPart or not HumanoidRootPart.Parent then
            if currentCircleTask then
                currentCircleTask:Disconnect()
                currentCircleTask = nil
            end
            return
        end

        angle = angle + speed * dt * 60
        local x = currentCenterPosition.X + math.cos(angle) * radius
        local z = currentCenterPosition.Z + math.sin(angle) * radius
        
        HumanoidRootPart.CFrame = CFrame.new(
            Vector3.new(x, HumanoidRootPart.Position.Y, z),
            currentCenterPosition
        )
    end)
end

-- æ¸…ç†è¿åŠ¨æ•ˆæœå¹¶éªŒè¯
local function cleanupMovement()
    -- è®°å½•æ¸…ç†å¼€å§‹æ—¶é—´
    local startTime = os.time()
    local maxWaitTime = 5 -- æœ€å¤§ç­‰å¾…æ—¶é—´(ç§’)
    
    -- å…ˆåœæ­¢æ‰€æœ‰ä»»åŠ¡
    if currentFloatTask then
        currentFloatTask:Disconnect()
        currentFloatTask = nil
    end
    if currentCircleTask then
        currentCircleTask:Disconnect()
        currentCircleTask = nil
    end
    
    -- è·å–è§’è‰²å’Œéƒ¨ä»¶
    local Character = player.Character
    if not Character then
        warn("æ¸…ç†è¿åŠ¨æ•ˆæœ: è§’è‰²ä¸å­˜åœ¨")
        return false
    end
    
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    local Humanoid = Character:FindFirstChild("Humanoid")
    
    if not HumanoidRootPart or not Humanoid then
        warn("æ¸…ç†è¿åŠ¨æ•ˆæœ: ç¼ºå°‘å¿…è¦éƒ¨ä»¶")
        return false
    end
    
    -- ç§»é™¤æ‰€æœ‰ç‰©ç†æ§åˆ¶å™¨
    for _, child in ipairs(HumanoidRootPart:GetChildren()) do
        if child:IsA("BodyPosition") or child:IsA("BodyForce") then
            child:Destroy()
        end
    end
    
    -- æ¢å¤è§’è‰²çŠ¶æ€
    Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    
    -- éªŒè¯æµ®ç©ºæ˜¯å¦æˆåŠŸå…³é—­
    local function isFloatingCleared()
        -- æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ç‰©ç†æ§åˆ¶å™¨
        for _, child in ipairs(HumanoidRootPart:GetChildren()) do
            if child:IsA("BodyPosition") or child:IsA("BodyForce") then
                return false
            end
        end
        
        -- æ£€æŸ¥è§’è‰²çŠ¶æ€
        if Humanoid:GetState() == Enum.HumanoidStateType.Physics then
            return false
        end
        
        -- æ£€æŸ¥è§’è‰²æ˜¯å¦åœ¨åœ°é¢
        if not Humanoid:GetState() == Enum.HumanoidStateType.Running and 
           not Humanoid:GetState() == Enum.HumanoidStateType.RunningNoPhysics then
            -- é¢å¤–æ£€æŸ¥: ä½¿ç”¨å°„çº¿æ£€æµ‹åˆ¤æ–­æ˜¯å¦åœ¨åœ°é¢
            local rayOrigin = HumanoidRootPart.Position
            local rayDirection = Vector3.new(0, -5, 0)
            local raycastParams = RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {Character}
            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
            
            local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
            if not raycastResult then
                return false
            end
        end
        
        return true
    end
    
    -- ç­‰å¾…ç›´åˆ°æµ®ç©ºæ•ˆæœæ¸…é™¤æˆ–è¶…æ—¶
    while os.time() - startTime < maxWaitTime do
        if isFloatingCleared() then
            print("æµ®ç©ºæ•ˆæœå·²æˆåŠŸæ¸…é™¤")
            return true
        end
        wait(0.1)
    end
    
    warn("æ¸…ç†è¿åŠ¨æ•ˆæœ: è¶…æ—¶æœªèƒ½å®Œå…¨æ¸…é™¤æµ®ç©ºæ•ˆæœ")
    return false
end

-- ä¿®æ”¹é€€å‡ºæˆ˜æ–—å‡½æ•°ï¼Œæ·»åŠ éªŒè¯
local function leaveArena()
    local cleanupSuccess = false
    local maxAttempts = 3
    local attempts = 0
    
    repeat
        attempts = attempts + 1
        print(string.format("å°è¯•ç¦»å¼€ç«æŠ€åœº (ç¬¬%dæ¬¡)...", attempts))
        
        -- å…ˆå°è¯•æ¸…ç†è¿åŠ¨æ•ˆæœ
        cleanupSuccess = cleanupMovement()
        
        if cleanupSuccess then
            -- å‘é€ç¦»å¼€è¯·æ±‚
            local args = {"ArenaSystemLeaveChannel"}
            local success, err = pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("CommonLibrary"):WaitForChild("Tool"):WaitForChild("RemoteManager"):WaitForChild("Funcs"):WaitForChild("DataPullFunc"):InvokeServer(unpack(args))
            end)
            
            if success then
                print("æˆåŠŸå‘é€ç¦»å¼€ç«æŠ€åœºè¯·æ±‚")
                return true
            else
                warn("ç¦»å¼€ç«æŠ€åœºè¯·æ±‚å¤±è´¥:", err)
            end
        else
            warn("æ¸…ç†è¿åŠ¨æ•ˆæœå¤±è´¥ï¼Œå°†é‡è¯•...")
        end
        
        wait(1)
    until cleanupSuccess or attempts >= maxAttempts
    
    if not cleanupSuccess then
        warn("å¤šæ¬¡å°è¯•åä»æœªèƒ½ç¦»å¼€ç«æŠ€åœº")
    end
    
    return cleanupSuccess
end

-- ä¿®æ”¹æµ®ç©ºæ§åˆ¶å‡½æ•°ï¼Œæ·»åŠ éªŒè¯
local function floatAbovePosition()
    -- å…ˆç¡®ä¿ä¹‹å‰çš„è¿åŠ¨æ•ˆæœå·²æ¸…é™¤
    if not cleanupMovement() then
        warn("æ— æ³•å¯åŠ¨æ–°æµ®ç©º: ä¹‹å‰çš„è¿åŠ¨æ•ˆæœæœªæ¸…é™¤")
        return false
    end

    local Character = player.Character or player.CharacterAdded:Wait()
    local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    local Humanoid = Character:WaitForChild("Humanoid")

    -- åˆ›å»ºæµ®ç©ºæ§åˆ¶å™¨
    local bodyPos = Instance.new("BodyPosition")
    bodyPos.Position = HumanoidRootPart.Position + Vector3.new(0, 21, 0)
    bodyPos.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bodyPos.D = 1000
    bodyPos.P = 10000
    bodyPos.Parent = HumanoidRootPart

    local bodyForce = Instance.new("BodyForce")
    bodyForce.Force = Vector3.new(0, HumanoidRootPart:GetMass() * workspace.Gravity, 0)
    bodyForce.Parent = HumanoidRootPart

    Humanoid:ChangeState(Enum.HumanoidStateType.Physics)

    -- éªŒè¯æµ®ç©ºæ˜¯å¦æˆåŠŸå¯åŠ¨
    local function isFloatingStarted()
        -- æ£€æŸ¥æ§åˆ¶å™¨æ˜¯å¦å­˜åœ¨
        if not HumanoidRootPart:FindFirstChildOfClass("BodyPosition") or
           not HumanoidRootPart:FindFirstChildOfClass("BodyForce") then
            return false
        end
        
        -- æ£€æŸ¥è§’è‰²çŠ¶æ€
        if Humanoid:GetState() ~= Enum.HumanoidStateType.Physics then
            return false
        end
        
        return true
    end
    
    local startTime = os.time()
    local maxWaitTime = 2 -- æœ€å¤§ç­‰å¾…æ—¶é—´(ç§’)
    
    while os.time() - startTime < maxWaitTime do
        if isFloatingStarted() then
            break
        end
        wait(0.1)
    end
    
    if not isFloatingStarted() then
        warn("æµ®ç©ºå¯åŠ¨éªŒè¯å¤±è´¥")
        cleanupMovement()
        return false
    end

    task.wait(0.5)
    
    currentCenterPosition = getViewForwardCenter()
    if currentCenterPosition then
        startCircleMovement()
    else
        warn("æ— æ³•è·å–ä¸­å¿ƒç‚¹ä½ç½®")
    end

    currentFloatTask = game:GetService("RunService").Heartbeat:Connect(function()
        if not running then
            cleanupMovement()
            return
        end

        if isWaitClearVisible() then
            cleanupMovement()
        end
    end)
    
    return true
end

-- BossåŒºåŸŸæ£€æµ‹ (ä½¿ç”¨è‡ªåŠ¨æ›´æ–°çš„è·¯å¾„)
local function checkBossArea(areaId)
    local pathData = monsterPaths[areaId]
    if not pathData or not pathData.guiAth then
        warn("["..areaId.."] è·¯å¾„æ•°æ®ä¸å­˜åœ¨æˆ–GuiAthç¼ºå¤±")
        return false
    end

    local function searchLabCd(instance)
        if instance:IsA("TextLabel") and instance.Name == "LabCdTime" then
            local text = instance.Text
            return text == "LabCdTime" or (string.find(text, "00:00:00") ~= nil)
        end
        for _, child in ipairs(instance:GetChildren()) do
            if searchLabCd(child) then return true end
        end
        return false
    end

    return searchLabCd(pathData.guiAth)
end

-- æ£€æŸ¥çµå…½è§¦å‘æ¡ä»¶
local function checkLingShouCondition()
    local waitFrame = safeGet({
        "Players", player.Name, 
        "PlayerGui", "Gui", 
        "ScreenGui", "ArenaStatusView", 
        "WaitClearFrame"
    })
    return waitFrame and waitFrame:IsA("Frame") and waitFrame.Visible
end

local PathTool = require(game:GetService("ReplicatedStorage").CommonLibrary.Tool.PathTool)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataPullFunc = ReplicatedStorage:WaitForChild("CommonLibrary"):WaitForChild("Tool"):WaitForChild("RemoteManager"):WaitForChild("Funcs"):WaitForChild("DataPullFunc")

-- Wait for player data to load
local player = Players.LocalPlayer
while not PathTool.ClientPlayerManager.GetGamePlayer() do
    task.wait(1)
end
local gamePlayer = PathTool.ClientPlayerManager.GetGamePlayer()

local function checkLingShouSystem(areaId)
    if not lingShouAreaConfig[areaId] then
        print("Area not enabled for LingShou capture")
        return leaveArena()
    end

    -- Verify we're in a valid arena state
    local arenaStatus = PathTool.FindForPath(player.PlayerGui, "Gui.ScreenGui.ArenaStatusView")
    if not arenaStatus or not arenaStatus:IsA("Frame") then
        warn("Not in arena - cannot capture")
        return false
    end
    
    -- Check for WaitClearFrame (capture available)
    local waitFrame = PathTool.FindForPath(arenaStatus, "WaitClearFrame")
    if not (waitFrame and waitFrame:IsA("Frame") and waitFrame.Visible) then
        warn("Capture not available yet")
        return false
    end
    
    -- Get all monsters in the arena
    local monsters = workspace.Monsters:GetChildren()
    if #monsters == 0 then
        warn("No monsters found")
        return false
    end
    
    -- Process each monster
    for _, monster in ipairs(monsters) do
        local monsterId = tonumber(string.match(monster.Name, "%d+"))
        if monsterId then
            print("Attempting capture on monster:", monsterId)
            
            -- Trigger dead effect first
            local deadEffectSuccess = pcall(function()
                DataPullFunc:InvokeServer("MonsterDeadEffectChannel", monsterId, "Tp_Transparency")
            end)
            
            if not deadEffectSuccess then
                warn("Failed to trigger dead effect")
            end
            
            -- Perform capture attempts (standard 3 rolls)
            for i = 1, 3 do
                local success, result = pcall(function()
                    return DataPullFunc:InvokeServer(
                        "LingShouSystemRollChannel",
                        monsterId,
                        1  -- Single roll
                    )
                end)
                
                if success then
                    print(string.format("Capture attempt %d successful", i))
                else
                    warn(string.format("Capture attempt %d failed:", i), result)
                end
                
                task.wait(0.1)
            end
            
            -- Force cleanup if needed
            pcall(function()
                for _, part in ipairs(monster:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.Transparency = 1
                        part.CanCollide = false
                    end
                end
                monster:Destroy()
            end)
        end
    end
    
    -- Leave arena after capture
end

-- Add this monitoring system to handle persistent bodies
task.spawn(function()
    while true do
        for _, monster in ipairs(workspace.Monsters:GetChildren()) do
            if monster:GetAttribute("DeathTime") and (os.time() - monster:GetAttribute("DeathTime") > 30) then
                warn("Force cleaning persistent monster body")
                monster:Destroy()
            end
        end
        task.wait(5)
    end
end)

-- é‡æ–°è¿æ¥æœåŠ¡å™¨
local RECONNECT_INTERVAL = 1800 -- 30åˆ†é’Ÿ(ç§’)
local lastReconnectCheck = os.time()

local function reconnectToServer()
    if not settings.autoReconnect then return end
    
    print("å¼€å§‹æ‰§è¡Œè‡ªåŠ¨é‡è¿æµç¨‹...")
    running = false  -- Pause monitoring
    
    -- Cleanup any active processes
    if currentFloatTask then currentFloatTask:Disconnect() end
    if currentCircleTask then currentCircleTask:Disconnect() end
    cleanupMovement()
    
    wait(1)  -- Ensure cleanup completes
    
    local _place = game.PlaceId
    local _servers = "https://games.roblox.com/v1/games/".._place.."/servers/Public?sortOrder=Asc&limit=10"
    
    -- Freeze character if exists
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.Anchored = true
    end
    
    -- Attempt reconnection
    local success = pcall(function()
        local servers = game:GetService("HttpService"):JSONDecode(game:HttpGet(_servers))
        if servers and #servers.data > 0 then
            local server = servers.data[math.random(1, math.min(#servers.data, 10))]
            game:GetService("TeleportService"):TeleportToPlaceInstance(_place, server.id, player)
        else
            game:GetService("TeleportService"):Teleport(_place, player)
        end
    end)
    
    if not success then
        warn("é‡è¿å¤±è´¥ï¼Œ5ç§’åé‡è¯•...")
        wait(5)
        running = true  -- Resume operations if failed
    end
end
-- ä¸»å¾ªç¯
local function main()
    lastReconnectCheck = os.time()
    local lastCheckTime = os.time()
    
    while running do
        local currentTime = os.time()
        if settings.autoReconnect and (currentTime - lastReconnectCheck >= 1800) then
            print("30åˆ†é’Ÿå·²åˆ°ï¼Œæ‰§è¡Œè‡ªåŠ¨é‡è¿...")
            reconnectToServer()
            lastReconnectCheck = os.time()  -- Reset timer
        end
        -- æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡ï¼ˆå¸¦è°ƒè¯•è¾“å‡ºï¼‰
        if currentTime - lastCheckTime >= 60 then
            lastCheckTime = currentTime
            print("æ‰§è¡Œå®šæœŸæ£€æŸ¥...")
            
            if settings.autoReconnect and os.time() - lastReconnectCheck >= RECONNECT_INTERVAL then
                print("æ»¡è¶³é‡è¿æ¡ä»¶ï¼Œå¼€å§‹é‡è¿...")
                reconnectToServer()
                lastReconnectCheck = os.time() -- é‡ç½®è®¡æ—¶å™¨
            end
        end
        
         for areaId, enabled in pairs(areaConfig) do
            if enabled and not isInBattle() and not hasEnteredBattle then
                local success, ready = pcall(checkBossArea, areaId)
                if success and ready then
                    print("["..areaId.."] å¯è¿›å…¥æˆ˜æ–—")
                    
                    -- Add 5-second wait before joining battle
                    print("ç­‰å¾…5ç§’åå†è¿›å…¥æˆ˜æ–—...")
                    local waitStart = os.time()
                    while os.time() - waitStart < 5 and running do
                        wait(0.1)
                    end
                    if not running then break end
                    
                    local args = {"ArenaStartSoloArenaChannel", areaId}
                    local invokeSuccess, err = pcall(function()
                        game:GetService("ReplicatedStorage").CommonLibrary.Tool.RemoteManager.Funcs.DataPullFunc:InvokeServer(unpack(args))
                    end
                    
                    if invokeSuccess then
                        print("æˆ˜æ–—è¯·æ±‚å·²å‘é€")
                        hasEnteredBattle = true
                        
                        local startTime = os.time()
                        local hasTriggered = false
                        local floatSuccess = false
                        
                        while running and (os.time() - startTime < 15) do
                            if isInBattle() and not hasTriggered then
                                print("è¿›å…¥æˆ˜æ–—ï¼Œå¯åŠ¨æµ®ç©ºç³»ç»Ÿ")
                                floatSuccess = floatAbovePosition()
                                
                                if floatSuccess then
                                    hasTriggered = true
                                    
                                    -- æˆ˜æ–—å†…å¾ªç¯
                                    while running and isInBattle() do
                                        if checkLingShouCondition() then
                                            local lsSuccess = checkLingShouSystem(areaId)
                                            if not lsSuccess then
                                                -- çµå…½æ•æ‰å¤±è´¥ï¼Œå¯èƒ½éœ€è¦é‡æ–°å°è¯•
                                                wait(1)
                                            end
                                        end
                                        wait(0.5)
                                    end
                                    break
                                else
                                    warn("æµ®ç©ºå¯åŠ¨å¤±è´¥ï¼Œå°†é‡è¯•...")
                                    wait(1)
                                end
                            end
                            wait(0.3)
                        end
                    else
                        warn("æˆ˜æ–—è¯·æ±‚å¤±è´¥:", err)
                    end
                end
            end
        end

        -- æˆ˜æ–—ç»“æŸåä¼ é€åˆ°ç›®æ ‡ä½ç½®
        if hasEnteredBattle and not isInBattle() then
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            if cleanupMovement() then
                print("æˆ˜æ–—ç»“æŸï¼Œæ­£åœ¨ä¼ é€...")
                -- Add small delay before teleport
                wait(1.5) 
                character:FindFirstChild("HumanoidRootPart").CFrame = CFrame.new(targetPosition)
                print("ä¼ é€å®Œæˆ")
            end
        end
        hasEnteredBattle = false -- Reset AFTER teleport completes
        -- Refresh paths after each battle
        monsterPaths = getMonsterPaths() 
    end

    wait(0.5)
end



end

-- åœæ­¢åŠŸèƒ½
stopBtn.MouseButton1Click:Connect(function()
    running = false
    cleanupMovement()
    gui:Destroy()
end)

-- å¯åŠ¨è„šæœ¬
local success, err = pcall(main)
if not success then
    warn("è„šæœ¬é”™è¯¯:", err)
    gui:Destroy()
end
