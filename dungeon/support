--================= é…ç½® =================--
local TARGET_GAME_ID_1 = 113080689665370
local TARGET_GAME_ID_2 = 120876398824321
local TARGET_GAME_ID_3 = 72607172956362
if game.PlaceId ~= TARGET_GAME_ID_1 and game.PlaceId ~= TARGET_GAME_ID_2 and game.PlaceId ~= TARGET_GAME_ID_3 then
    print("âš ï¸ wrong game")
    return
end

if not game:IsLoaded() then
    game.Loaded:Wait()
end
wait(3)
--================= åŠ è½½UIåº“ =================--
local library = loadstring(
    game:HttpGet(
        'https://raw.githubusercontent.com/supleruckydior/test/refs/heads/main/menu.json',
        true
    )
)()

-- é˜²AFK
local AntiAFK = game:GetService('VirtualUser')
game.Players.LocalPlayer.Idled:Connect(function()
    AntiAFK:CaptureController()
    AntiAFK:ClickButton2(Vector2.new())
    wait(2)
end)

--================= æœåŠ¡å¼•ç”¨ =================--
local Players = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local ReplicatedFirst = game:GetService('ReplicatedFirst')
local Workspace = game:GetService('Workspace')
local HttpService = game:GetService('HttpService')
local TeleportService = game:GetService('TeleportService')
local player = Players.LocalPlayer
local TNet = require(ReplicatedFirst.Component.TNet)
local Config = require(ReplicatedStorage.Config)
local RunService = game:GetService("RunService")
local TNetSent = ReplicatedStorage:WaitForChild("TNetSent")
local EquipmentShare = require(ReplicatedStorage.ClientBase.EquipmentShare)
--================= è®¾ç½®ä¿å­˜ =================--
local SettingsFile = 'DungeonSettings_'..player.Name..'.json'
local Settings = {
    AutoDungeonEnabled = false,
    SelectedDungeon = '1-1',
    AutoSkillEnabled = false,
    HealthMonitorEnabled = true,
    RoundTeleportEnabled = true,
    RoundTeleportThreshold = 55,
    AutoAttackEnabled = false,  -- æ–°å¢çš„åŠŸèƒ½
}

pcall(function()
    if isfile and isfile(SettingsFile) then
        Settings = HttpService:JSONDecode(readfile(SettingsFile))
    end
end)

local function SaveSettings()
    if writefile then
        writefile(SettingsFile, HttpService:JSONEncode(Settings))
    end
end

--================= Dungeon é…ç½® =================--
local DungeonOptions = {
    '1-1','1-2','1-3','2-1','2-2','2-3',
    '3-1','3-2','3-3','4-1','4-2','4-3',
    'endless-1','endless-16','endless-31','endless-46','endless-61','',''
}

local DungeonMap = {
    ['1-1']={1300001,1},['1-2']={1300001,2},['1-3']={1300001,3},
    ['2-1']={1300002,1},['2-2']={1300002,2},['2-3']={1300002,3},
    ['3-1']={1300003,1},['3-2']={1300003,2},['3-3']={1300003,3},
    ['4-1']={1300004,1},['4-2']={1300004,2},['4-3']={1300004,3},
    ['endless-1']={3200001,1},['endless-16']={3200001,16},
    ['endless-31']={3200001,31},['endless-46']={3200001,46},
    ['endless-61']={3200001,61}
}

--================= è¿›å…¥å‰¯æœ¬é€»è¾‘ =================--
local dungeonLock = false

local function EnterDungeon(dungeonId, difficulty)
    if dungeonLock then
        print('[DEBUG] å·²ç»åœ¨è¿›å…¥å‰¯æœ¬é”å®šçŠ¶æ€ï¼Œè·³è¿‡')
        return
    end
    dungeonLock = true
    task.delay(10, function() dungeonLock = false end)

    repeat task.wait() until Workspace:FindFirstChild('Lobby')
    local lobby = Workspace:FindFirstChild('Lobby')

    local function FindIdleTable()
        local lobbySection = Workspace.Lobby:FindFirstChild('\229\140\185\233\133\141\229\140\186')
        if not lobbySection then return nil end
        for i=4,#lobbySection:GetChildren() do
            local tableObj = lobbySection:GetChildren()[i]
            local match = tableObj:FindFirstChild('Match')
            if match and match:FindFirstChild('BillboardGui') then
                local idle = match.BillboardGui:FindFirstChild('Idle')
                if idle and idle.Visible then return match end
            end
        end
        return nil
    end

    local tableObj = FindIdleTable()
    if not tableObj then
        print('[DEBUG] æ²¡æœ‰æ‰¾åˆ°ç©ºé—²æ¡Œå­')
        dungeonLock = false
        return
    end

    if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') then
        print('[DEBUG] ç©å®¶è§’è‰²æˆ– HumanoidRootPart æœªå°±ç»ª')
        dungeonLock = false
        return
    end

    print('[DEBUG] ç§»åŠ¨åˆ°æ¡Œå­:', tableObj.Parent.Name)
    player.Character.HumanoidRootPart.CFrame = CFrame.new(tableObj.Position)
    task.wait(0.6)

    print('[DEBUG] é€‰æ‹©å‰¯æœ¬ ID:', dungeonId, 'éš¾åº¦:', difficulty)
    pcall(function() TNet.FireServer('Dungeon_Select', dungeonId, difficulty) end)
    task.wait(0.1)

    print('[DEBUG] å¼€å§‹å‰¯æœ¬')
    pcall(function() TNet.FireServer('Dungeon_StartParty') end)

    task.delay(2, function()
        dungeonLock = false
        print('[DEBUG] è§£é™¤è¿›å…¥å‰¯æœ¬é”å®š')
    end)
end

--================= UI åˆå§‹åŒ– =================--
local window = library:AddWindow('DUNGEON LOOTIFY v2.8',{main_color=Color3.fromRGB(41,74,122), min_size=Vector2.new(530,490)})
local features = window:AddTab('åŠŸèƒ½')
local features1 = window:AddTab('æ‚é¡¹')
-- è‡ªåŠ¨è¿›å…¥å‰¯æœ¬å¼€å…³
local autoJoinSwitch = features:AddSwitch('è‡ªåŠ¨è¿›å…¥å‰¯æœ¬', function(bool)
    Settings.AutoDungeonEnabled = bool
    SaveSettings()
end)
if autoJoinSwitch.Set then autoJoinSwitch:Set(Settings.AutoDungeonEnabled) end

-- å½“å‰é€‰æ‹©å…³å¡
local selectedLabel = features:AddLabel('å½“å‰é€‰æ‹©: ' .. Settings.SelectedDungeon)
local dungeonDropdown = features:AddDropdown('é€‰æ‹©åœ°ä¸‹åŸ', function(text)
    local cleaned = text:match('^%s*(.-)%s*$') or text
    if cleaned ~= '' then
        Settings.SelectedDungeon = cleaned
        SaveSettings()
        if selectedLabel.Set then 
            selectedLabel:Set('å½“å‰é€‰æ‹©: ' .. cleaned)
        end
    end
end)
for _, name in ipairs(DungeonOptions) do
    dungeonDropdown:Add(name)
end
if dungeonDropdown.Set then
    dungeonDropdown:Set(Settings.SelectedDungeon)
end
-- æ­¦å™¨é…ç½®é€‰é¡¹
local weaponOptions = {
    ["SwordShield"] = "SwordShield1",
    ["DuoSword"]    = "Duosword1",
    ["Wood"]        = "Wood1"
}

-- å¦‚æœæ²¡è®¾ç½®è¿‡ï¼Œå°±ç»™é»˜è®¤å€¼
if not Settings.SelectedWeapon then
    Settings.SelectedWeapon = "SwordShield"
    SaveSettings()
end

-- æ­¦å™¨ä¸‹æ‹‰èœå•
local weaponDropdown = features:AddDropdown("é€‰æ‹©æ­¦å™¨", function(choice)
    if weaponOptions[choice] then
        Settings.SelectedWeapon = choice
        SaveSettings()
        print("[Killaura] å·²åˆ‡æ¢æ­¦å™¨:", choice, "åŠ¨ç”»:", weaponOptions[choice])
    end
end)

-- åˆå§‹åŒ–ä¸‹æ‹‰æ¡†æ˜¾ç¤ºä¸Šæ¬¡ä¿å­˜çš„å€¼
for weaponName, _ in pairs(weaponOptions) do
    weaponDropdown:Add(weaponName)
end
if weaponDropdown.Set then
    weaponDropdown:Set(Settings.SelectedWeapon)
end
-- ================= killaura åˆ¤æ–­é€»è¾‘ =================
-- å…¨å±€å˜é‡
_G.KillauraKey = nil       -- å¼€å±€ä¸º nil
_G.KillauraReady = false   -- æ˜¯å¦å¯ä»¥å¯åŠ¨ killaura å’Œ SetupInDungeon

local function sendWeaponOnHit()
    local args = {
        Workspace:GetServerTimeNow(), -- timestamp å›ºå®šæˆ–å½“å‰æ—¶é—´
        1,
        "SwordShield",
        {
            hitNum = 0,
            onHitAnimName = "SwordShield1",
            hrtCF = CFrame.fromMatrix(
                Vector3.new(-332.72, 1003.56, 1.07),
                Vector3.new(0.52, 0.00, 0.85),
                Vector3.new(0.00, 1.00, 0.00),
                Vector3.new(-0.85, 0.00, 0.52)
            )
        }
    }
    TNet.FireServer("Weapon_OnHit", unpack(args))
    print("[DEBUG] Weapon_OnHit å‘é€æˆåŠŸ")
end

-- Hook TNetSentï¼Œåªæ•è·å®¢æˆ·ç«¯å‘å‡ºçš„ç‰¹å®šäº‹ä»¶
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if self == TNetSent and method == "FireServer" then
        if type(args[1]) == "string" and type(args[3]) == "number" then
            print("[DEBUG] æ•è· TNetSent:", args[1], args[3])
            _G.KillauraKey = args[1]          -- æ›´æ–° Key
            _G.KillauraReady = true           -- å¯ä»¥å¯åŠ¨é€»è¾‘

            -- æ•è·åç«‹å³è¿˜åŸ hook
            hookmetamethod(game, "__namecall", oldNamecall)

            print("[DEBUG] Hook å·²è¿˜åŸ")
        end
    end

    return oldNamecall(self, ...)
end)

-- å¾ªç¯å‘é€ Weapon_OnHit ç›´åˆ°æ•è· Key
spawn(function()
    while not _G.KillauraKey do
        sendWeaponOnHit()
        task.wait(5) -- èŠ‚æµï¼Œé¿å…å´©æºƒ
    end
end)

-- ç­‰å¾… Key åå¯åŠ¨é€»è¾‘
spawn(function()
    while not _G.KillauraReady do
        task.wait(0.1)
    end

    print("[DEBUG] Key æ•è·å®Œæˆï¼Œå¯åŠ¨é€»è¾‘")

end)




-- ================= killaura å¼€å…³ =================
features:AddSwitch("killaura", function(state)
    Settings.AutoAttackEnabled = state
    SaveSettings()

    if state then
        print("[AutoAttack] è‡ªåŠ¨æ”»å‡»å·²å¼€å¯")

        -- æœåŠ¡è·å–
        local Workspace = game:GetService("Workspace")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RunService = game:GetService("RunService")

        local TNetSent = ReplicatedStorage:WaitForChild("TNetSent")

        local cycleIndex, attackId = 1, 0
        local lastPositions = {}

        -- ç­‰å¾… _G.KillauraKey æ•è·
        while not _G.KillauraKey do
            task.wait(0.1)
        end
        print("[AutoAttack] æ•è·åˆ° KillauraKey =", _G.KillauraKey)

        local function getServerTime()
            return Workspace:GetServerTimeNow()
        end

        local function attack(enemy, cf)
            local weaponName = Settings.SelectedWeapon
            local animName   = weaponOptions[weaponName] or "SwordShield1"

            local args = {
                _G.KillauraKey, -- æ›¿æ¢ Bd ä¸ºæ•è·åˆ°çš„ Key
                attackId,
                getServerTime(),
                cycleIndex,
                weaponName,
                {
                    hitNum = math.random(0,5),
                    onHitAnimName = animName,
                    hrtCF = cf
                }
            }
            TNetSent:FireServer(unpack(args))

            cycleIndex = cycleIndex + 1
            if cycleIndex > 1 then cycleIndex = 1 end
            attackId = attackId + 1
        end

        local function getPredictedCFrame(enemy, dt)
            local root = enemy:FindFirstChild("HumanoidRootPart")
            if not root then return nil end
            local lastPos = lastPositions[enemy] or root.Position
            local currentPos = root.Position
            local velocity = (currentPos - lastPos) / dt
            local predictionFactor = 0.1
            local predictedPos = currentPos + velocity * predictionFactor
            lastPositions[enemy] = currentPos
            return CFrame.new(predictedPos)
        end

local IgnoreList = {
    ["84f0df6486bd4efa"] = true
}

local function getClosestEnemy(dt)
    local closest, shortestDist = nil, math.huge
    local playerPos = workspace.CurrentCamera and workspace.CurrentCamera.CFrame.Position or Vector3.new(0,0,0)

    for _, room in ipairs(Workspace:GetChildren()) do
        if room:IsA("Model") and (room:FindFirstChild("EnemySpawnPoint") or room:FindFirstChild("EnemySpawnArea")) then
            for _, obj in ipairs(room:GetChildren()) do
                if obj:IsA("Model") 
                   and obj:FindFirstChild("HumanoidRootPart") 
                   and not IgnoreList[obj.Name] then   -- ğŸ”¹è·³è¿‡å¿½ç•¥ç›®æ ‡

                    local root = obj.HumanoidRootPart
                    local isBoss = false
                    local typeAttr = obj:GetAttribute("Type")
                    if typeAttr and string.find(string.lower(typeAttr), "boss") then
                        isBoss = true
                    end

                    local healthTextObj = root:FindFirstChild("Health") 
                        and root.Health:FindFirstChild("Canvas") 
                        and root.Health.Canvas:FindFirstChild("Health") 
                        and root.Health.Canvas.Health:FindFirstChild("HealthText")
                    local healthNum = healthTextObj and tonumber(healthTextObj.Text:match("%d+")) or 0

                    if isBoss or (healthNum and healthNum > 0) then
                        local dist = (root.Position - playerPos).Magnitude
                        if dist < shortestDist then
                            shortestDist, closest = dist, obj
                        end
                    end
                end
            end
        end
    end

    if closest then
        return getPredictedCFrame(closest, dt), closest
    end
    return nil, nil
end

        -- ä¸»å¾ªç¯
        if not _G.AutoAttackConnection then
            _G.AutoAttackConnection = RunService.Heartbeat:Connect(function(dt)
                if not Settings.AutoAttackEnabled then return end
                local cf, enemy = getClosestEnemy(dt)
                if cf and enemy then
                    attack(enemy, cf)
                end
            end)
        end

    else
        print("[AutoAttack] è‡ªåŠ¨æ”»å‡»å·²å…³é—­")
        if _G.AutoAttackConnection then
            _G.AutoAttackConnection:Disconnect()
            _G.AutoAttackConnection = nil
        end
    end
end):Set(Settings.AutoAttackEnabled)




-- ================= æ¨¡æ‹Ÿæ”»å‡»å¼€å…³ =================
local function shiftKey(key)
    if #key == 0 then return key end
    local result = key:sub(1,1) -- ä¿ç•™ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸å˜
    for i = 2, #key do
        local c = key:sub(i,i)
        local byte = c:byte()
        if byte >= 65 and byte <= 90 then -- å¤§å†™ A-Z
            result = result .. string.char(65 + (byte - 65 + 1) % 26)
        elseif byte >= 97 and byte <= 122 then -- å°å†™ a-z
            result = result .. string.char(97 + (byte - 97 + 1) % 26)
        else
            result = result .. c -- éå­—æ¯ä¿æŒä¸å˜
        end
    end
    return result
end


local attackSwitch = features:AddSwitch("åˆ·æŠ€èƒ½æ— å†·å´", function(state)
    Settings.SimulatedAttackEnabled = state
    SaveSettings()
    if state then
        if not _G.SimAttackThread then
            _G.SimAttackThread = spawn(function()
                while not _G.KillauraKey do
                    print("[SimulatedAttack] ç­‰å¾… _G.KillauraKey æ•è·ä¸­...")
                    task.wait(1)
                end
                print("[SimulatedAttack] å·²æ•è·åˆ° Key:", _G.KillauraKey)
                local newKey = shiftKey(_G.KillauraKey) -- è¿™é‡ŒæŠŠæ¯ä¸ªå­—æ¯+1
                print("[SimulatedAttack] å·²æ•è·åˆ° newKey:", newKey)
                if Workspace:FindFirstChild('Lobby') then return end
                while Settings.SimulatedAttackEnabled do
                    task.wait(0.05)
                    local weaponName = Settings.SelectedWeapon
                    local animName   = weaponOptions[weaponName] or "SwordShield1"
                    local simulatedCFrame = CFrame.new(Vector3.new(10, 5, -20))

                    pcall(function()
                        TNet.FireServer(newKey, 1, Workspace:GetServerTimeNow(), 1, weaponName, {
                            hitNum = 0,
                            onHitAnimName = animName,
                            hrtCF = simulatedCFrame
                        })
                    end)
                end
            end)
        end
    else
        Settings.SimulatedAttackEnabled = false
        _G.SimAttackThread = nil
    end
end)


-- åˆå§‹åŒ–å¼€å…³çŠ¶æ€
if attackSwitch.Set then
    attackSwitch:Set(Settings.SimulatedAttackEnabled or false)
end


features:AddSwitch("è‡ªåŠ¨é‡è¯•å‰¯æœ¬", function(state)
    Settings.AutoDungeonRetry = state
    SaveSettings()

    if state then
        print("[AutoRetry] è‡ªåŠ¨å‰¯æœ¬é‡è¯•å·²å¼€å¯")

        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        local ReplicatedFirst = game:GetService("ReplicatedFirst")
        local TNet = require(ReplicatedFirst.Component.TNet)

        -- å¾ªç¯æ£€æµ‹
        spawn(function()
            while Settings.AutoDungeonRetry do
                task.wait(2)
                local success, gui = pcall(function()
                    return player.PlayerGui.Main.Func.DungeonObtain
                end)
                if success and gui and gui.Visible then
                    print("[AutoRetry] æ£€æµ‹åˆ° DungeonObtain å¯è§ï¼Œå‘é€ Dungeon_RetryCmd")
                    pcall(function()
                        TNet.FireServer("Dungeon_RetryCmd")
                    end)
                    break -- âœ… å‘é€ä¸€æ¬¡åç›´æ¥é€€å‡ºå¾ªç¯
                end
            end
        end)

    else
        print("[AutoRetry] è‡ªåŠ¨å‰¯æœ¬é‡è¯•å·²å…³é—­")
    end
end):Set(Settings.AutoDungeonRetry or false)

--================= è‡ªåŠ¨ä¼ é€ä¸å®ç®±å¼€å…³ =================--
features:AddSwitch("è‡ªåŠ¨ä¼ é€ & å¼€å®ç®±", function(state)
    Settings.AutoTeleportChests = state
    SaveSettings()

    if state then
        --================= åˆå§‹åŒ– =================--
        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")

        local player = Players.LocalPlayer

        local ignoredModels = {
            ["84f0df6486bd4efa"] = true,
        }

        local teleportDelay = 3 -- ç§’
        local openedChests = {} -- å·²å¼€å¯å®ç®±è®°å½•

        --================= å·¥å…·å‡½æ•° =================--

        local function hasBoss()
            for _, room in ipairs(Workspace:GetChildren()) do
                if room:IsA("Model") and (room:FindFirstChild("EnemySpawnPoint") or room:FindFirstChild("EnemySpawnArea")) then
                    for _, obj in ipairs(room:GetChildren()) do
                        if obj:IsA("Model") and obj:FindFirstChild("HumanoidRootPart") and not ignoredModels[obj.Name] then
                            local typeAttr = obj:GetAttribute("Type")
                            local hasBossChild = obj:FindFirstChild("Boss") ~= nil
                            if (typeAttr and string.find(string.lower(typeAttr), "boss")) or hasBossChild then
                                return true
                            end
                        end
                    end
                end
            end
            return false
        end

        local function hasEnemy()
            for _, room in ipairs(Workspace:GetChildren()) do
                if room:IsA("Model") and (room:FindFirstChild("EnemySpawnPoint") or room:FindFirstChild("EnemySpawnArea")) then
                    for _, obj in ipairs(room:GetChildren()) do
                        if obj:IsA("Model") and obj:FindFirstChild("HumanoidRootPart") and not ignoredModels[obj.Name] then
                            return true
                        end
                    end
                end
            end
            return false
        end

        local function getClosestDoor()
            local closestDoor, shortestDist = nil, math.huge
            local playerPos = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position
            if not playerPos then return nil end

            for _, room in ipairs(Workspace:GetChildren()) do
                local door = room:FindFirstChild("Door")
                if door then
                    local doorPos
                    if door.PrimaryPart then
                        doorPos = door.PrimaryPart.Position
                    else
                        local success, pivot = pcall(function() return door:GetPivot().Position end)
                        if success then doorPos = pivot else
                            local part = door:FindFirstChildWhichIsA("BasePart")
                            if part then doorPos = part.Position end
                        end
                    end
                    if doorPos then
                        local dist = (doorPos - playerPos).Magnitude
                        if dist < shortestDist then
                            shortestDist, closestDoor = dist, door
                        end
                    end
                end
            end
            return closestDoor
        end

        local function getFurthestDoorInRoom(room)
            if not room then return nil end
            local furthestDoor, maxDist = nil, -math.huge
            local playerPos = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position
            if not playerPos then return nil end

            for _, door in ipairs(room:GetChildren()) do
                if door:IsA("Model") and string.find(door.Name, "Door") and door:FindFirstChild("Collider") then
                    local collider = door:FindFirstChild("Collider")
                    local dist = (collider.Position - playerPos).Magnitude
                    if dist > maxDist then
                        maxDist = dist
                        furthestDoor = door
                    end
                end
            end
            return furthestDoor
        end

        local function teleportToDoorCollider(door)
            if not door or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
            local collider = door:FindFirstChild("Collider")
            if not collider then
                print("[TeleportTest] Door æ²¡æœ‰ Collider:", door.Name)
                return
            end
            player.Character.HumanoidRootPart.CFrame = CFrame.new(collider.Position + Vector3.new(0,3,0))
            print("[TeleportTest] å·²ä¼ é€åˆ°ç›®å½•:", door.Parent.Name, "Door:", door.Name, "Collider Pos:", collider.Position)
        end

        --================= å®ç®±ç›¸å…³ =================--

        local function getChestsInRoom(room)
            local chests = {}
            for _, obj in ipairs(room:GetChildren()) do
                if obj:IsA("Model") and string.find(obj.Name, "DungeonChest") then
                    if not openedChests[obj] then
                        table.insert(chests, obj)
                    end
                end
            end
            return chests
        end

        local function openChest(chest)
            if not chest or not chest:IsDescendantOf(workspace) then return end
            local prompt = chest:FindFirstChild("ProximityPrompt", true)
            if not prompt then return end

            local chestPos = chest.PrimaryPart and chest.PrimaryPart.Position or chest:GetPivot().Position
            player.Character.HumanoidRootPart.CFrame = CFrame.new(chestPos + Vector3.new(0,3,0))
            task.wait(1)
            prompt:InputHoldBegin()
            task.wait(1)
            prompt:InputHoldEnd()
            
            print("[Chest] å·²æ‰“å¼€å®ç®±:", chest.Name)
            openedChests[chest] = true
            task.wait(0.5)
        end

        --================= ä¸»å¾ªç¯ =================--

        task.spawn(function()
            while Settings.AutoTeleportChests do -- âœ… æ£€æŸ¥å¼€å…³çŠ¶æ€
                task.wait(1)
                if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then continue end

                if hasBoss() then
                    print("[AutoTest] æ£€æµ‹åˆ° Bossï¼Œåœæ­¢ä¼ é€è„šæœ¬")
                    break
                end

                if hasEnemy() then
                    print("[AutoTest] åœºæ™¯ä¸­å­˜åœ¨æ•Œäººï¼Œæš‚åœä¼ é€")
                    task.wait(1)
                else
                    local closestDoor = getClosestDoor()
                    if closestDoor and closestDoor.Parent then
                        local room = closestDoor.Parent
                        -- å…ˆè®°å½•æœ€è¿œé—¨ Collider
                        local furthestDoor = getFurthestDoorInRoom(room)
                        local furthestColliderPos = furthestDoor and furthestDoor:FindFirstChild("Collider") and furthestDoor.Collider.Position or nil

                        -- æ‰«æå®ç®±
                        local chests = getChestsInRoom(room)
                        if #chests > 0 then
                            table.sort(chests, function(a, b)
                                local pa = a.PrimaryPart and a.PrimaryPart.Position or a:GetPivot().Position
                                local pb = b.PrimaryPart and b.PrimaryPart.Position or b:GetPivot().Position
                                local playerPos = player.Character.HumanoidRootPart.Position
                                return (pa - playerPos).Magnitude < (pb - playerPos).Magnitude
                            end)
                            for _, chest in ipairs(chests) do
                                openChest(chest)
                            end
                        end

                        -- å®ç®±å¼€å®Œåï¼Œä¼ é€åˆ°æœ€è¿œé—¨ Collider
                        if furthestColliderPos then
                            player.Character.HumanoidRootPart.CFrame = CFrame.new(furthestColliderPos + Vector3.new(0,3,0))
                            print("[TeleportTest] å®ç®±å¤„ç†å®Œæ¯•ï¼Œä¼ é€åˆ°æœ€è¿œé—¨ Collider:", furthestDoor.Name, "Pos:", furthestColliderPos)
                            task.wait(teleportDelay)
                        end
                    end
                end
            end
            print("[AutoTeleport] å¾ªç¯ç»“æŸ")
        end)

    else
        print("[AutoTeleport] è‡ªåŠ¨ä¼ é€ä¸å®ç®±å·²å…³é—­")
    end
end):Set(Settings.AutoTeleportChests or false)


-- è‡ªåŠ¨åƒè¡€è¯å¼€å…³
local autoPotionSwitch = features:AddSwitch('è‡ªåŠ¨åƒè¡€è¯', function(bool)
    Settings.HealthMonitorEnabled = bool
    SaveSettings()
end)
if autoPotionSwitch.Set then autoPotionSwitch:Set(Settings.HealthMonitorEnabled) end
-- è·å–ç©å®¶

-- åˆ›å»ºå¼€å…³
local autodisable = features:AddSwitch('å…³é—­é€‰æ‹©å’Œæ–½æ³•åŠ¨ç”»', function(bool)
    Settings.DisableSkillAnimations = bool
    SaveSettings()

    -- å¦‚æœå¼€å…³å¼€å¯ï¼Œå°±ç¦ç”¨ç›¸å…³ LocalScript/Script
    if bool then
        -- ç¦ç”¨ GUI å†…çš„ LocalScript
        local endlessChooseScript = player.PlayerGui:FindFirstChild("Main") 
            and player.PlayerGui.Main:FindFirstChild("Func") 
            and player.PlayerGui.Main.Func:FindFirstChild("EndlessChoose") 
            and player.PlayerGui.Main.Func.EndlessChoose:FindFirstChild("EndlessChoose")
        if endlessChooseScript and endlessChooseScript:IsA("LocalScript") then
            endlessChooseScript.Disabled = true
        end

        -- ç¦ç”¨ ReplicatedStorage çš„ Script/LocalScript
        local clientRunTimeScript = game:GetService("ReplicatedStorage"):FindFirstChild("ClientBase")
            and game:GetService("ReplicatedStorage").ClientBase:FindFirstChild("Skill")
            and game:GetService("ReplicatedStorage").ClientBase.Skill:FindFirstChild("ClientRunTime")
        if clientRunTimeScript and (clientRunTimeScript:IsA("Script") or clientRunTimeScript:IsA("LocalScript")) then
            clientRunTimeScript.Disabled = true
        end
    end
end)

-- è®¾ç½®å¼€å…³åˆå§‹çŠ¶æ€
if autodisable.Set then
    autodisable:Set(Settings.DisableSkillAnimations)
end
-- æŠ€èƒ½å¾ªç¯é‡Šæ”¾å¼€å…³
local autoSkillSwitch = features:AddSwitch('æŠ€èƒ½å¾ªç¯é‡Šæ”¾', function(bool)
    Settings.AutoSkillEnabled = bool
    SaveSettings()
end)
if autoSkillSwitch.Set then autoSkillSwitch:Set(Settings.AutoSkillEnabled) end
-- edndlesså¾ªç¯é‡Šæ”¾å¼€å…³
features:AddSwitch('è‡ªåŠ¨é€‰æ‹© Endless', function(state)
    Settings.AutoEndlessChoose = state
    SaveSettings()

    -- ç¡®ä¿åªæ³¨å†Œä¸€æ¬¡ç›‘å¬
    if not _G.AutoEndlessListenerRegistered then
        _G.AutoEndlessListenerRegistered = true

        -- å…¨å±€æ³¨å†Œç›‘å¬
        TNet.SetEvent("Endless_ShowPlayerUpgrade", function(upgradeList)
            print("âš ï¸ æ”¶åˆ° Endless_ShowPlayerUpgrade ä¸‹å‘æ•°æ®:")
            for i, id in ipairs(upgradeList) do
                local upgradeInfo = Config.Endless.UpgradeList[id]
                local name = upgradeInfo and upgradeInfo.name or "æœªçŸ¥"
                local desc = upgradeInfo and upgradeInfo.description or "æ— æè¿°"
                print(string.format("Index[%d] -> ID: %d, åç§°: %s, æè¿°: %s", i, id, name, desc))
            end

            if Settings.AutoEndlessChoose then
                local chosenIndex = nil

                -- ä¼˜å…ˆæ‰¾åå­—åŒ…å« Crystalï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰
                for i, id in ipairs(upgradeList) do
                    local upgradeInfo = Config.Endless.UpgradeList[id]
                    if upgradeInfo and string.find(upgradeInfo.name:lower(), "crystal") then
                        chosenIndex = i
                        break
                    end
                end

                -- å¦‚æœæ²¡æœ‰æ‰¾åˆ° Crystalï¼Œåˆ™æ‰¾ Chest
                if not chosenIndex then
                    for i, id in ipairs(upgradeList) do
                        local upgradeInfo = Config.Endless.UpgradeList[id]
                        if upgradeInfo and string.find(upgradeInfo.name:lower(), "chest") then
                            chosenIndex = i
                            break
                        end
                    end
                end

                -- å¦‚æœè¿˜æ˜¯æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™æŒ‰ ID æœ€åæ•°å­—æœ€å¤§
                if not chosenIndex then
                    local maxLastDigit = -1
                    for i, id in ipairs(upgradeList) do
                        local lastDigit = tonumber(tostring(id):sub(-1)) or 0
                        if lastDigit > maxLastDigit then
                            maxLastDigit = lastDigit
                            chosenIndex = i
                        end
                    end
                end

                -- å‘é€é€‰æ‹©
                pcall(function()
                    print("[AutoEndless] è‡ªåŠ¨é€‰æ‹© Index:", chosenIndex)
                    TNet.FireServer("Endless_PlayerChoose", chosenIndex)
                end)
            end
        end)
    end
end):Set(Settings.AutoEndlessChoose)




-- å›åˆæ£€æµ‹å¼€å…³
local roundCheckSwitch = features:AddSwitch('å›åˆæ£€æŸ¥', function(bool)
    Settings.RoundTeleportEnabled = bool
    SaveSettings()
end)
if roundCheckSwitch.Set then roundCheckSwitch:Set(Settings.RoundTeleportEnabled) end

--================= å›åˆé˜ˆå€¼ä¸æ˜¾ç¤º =================--
if type(Settings.RoundTeleportThreshold) ~= 'number' then
    Settings.RoundTeleportThreshold = 55
    SaveSettings()
end
local RoundThresholdValue = Settings.RoundTeleportThreshold
-- å›åˆæ˜¾ç¤ºLabel
local roundLabel = features:AddLabel('å›åˆ: 0 / ' .. RoundThresholdValue)

-- åˆ·æ–°å‡½æ•°
local function UpdateRoundLabel(currentRound)
    currentRound = currentRound or 0
    roundLabel.Text = 'å›åˆ: ' .. currentRound .. ' / ' .. RoundThresholdValue
end
-- æ·»åŠ é˜ˆå€¼æ˜¾ç¤ºæ›´æ–°å‡½æ•°
local function UpdateThresholdDisplay()
    RoundThresholdValue = Settings.RoundTeleportThreshold
    -- æ›´æ–°å›åˆæ˜¾ç¤ºçš„é˜ˆå€¼éƒ¨åˆ†
    local currentRound = tonumber(string.match(roundLabel.Text, 'å›åˆ: (%d+)') or 0)
    roundLabel.Text = 'å›åˆ: ' .. currentRound .. ' / ' .. RoundThresholdValue
    print('[DEBUG] é˜ˆå€¼æ›´æ–°ä¸º:', RoundThresholdValue)
end
-- è®¾ç½®é€€å‡ºå›åˆé˜ˆå€¼è¾“å…¥æ¡†
local thresholdInput = features:AddTextBox('è®¾ç½®é€€å‡ºå›åˆé˜ˆå€¼', function(text)
    local num = tonumber(text)
    if num and num > 0 then
        Settings.RoundTeleportThreshold = num
        SaveSettings()
        UpdateThresholdDisplay()
        print('[DEBUG] é˜ˆå€¼è®¾ç½®ä¸º:', num)
    else
        -- è¾“å…¥æ— æ•ˆï¼Œç›´æ¥ä¿®æ”¹Textå±æ€§æ¢å¤åŸå€¼
        thresholdInput.Text = tostring(Settings.RoundTeleportThreshold)
        print('[WARN] æ— æ•ˆè¾“å…¥ï¼Œå·²æ¢å¤ä¸º:', Settings.RoundTeleportThreshold)
    end
end)
thresholdInput.Text = tostring(Settings.RoundTeleportThreshold)
print('[DEBUG] è¾“å…¥æ¡†åˆå§‹å€¼è®¾ç½®ä¸º:', Settings.RoundTeleportThreshold)
-- ä¸»å¾ªç¯åˆ·æ–°å›åˆ Label
spawn(function()
    while true do
        task.wait(0.5)
        local currentRound = 0
        pcall(function()
            local roundGui = player.PlayerGui:FindFirstChild('Main')
                and player.PlayerGui.Main:FindFirstChild('HomePage')
                and player.PlayerGui.Main.HomePage:FindFirstChild('EndlessTop')
                and player.PlayerGui.Main.HomePage.EndlessTop:FindFirstChild('Top')
                and player.PlayerGui.Main.HomePage.EndlessTop.Top:FindFirstChild('RoundTitle')
            if roundGui then
                currentRound = tonumber(string.match(roundGui.Text, '%d+')) or 0
            end
        end)
        UpdateRoundLabel(currentRound)
    end
end)


--================= è‡ªåŠ¨è¿›å…¥å‰¯æœ¬å¾ªç¯ =================--
spawn(function()
    while true do
        task.wait(5)
        if not Settings.AutoDungeonEnabled then continue end
        if Workspace:FindFirstChild('Lobby') then
            local sel = Settings.SelectedDungeon or '1-1'
            local dungeonId, difficulty = unpack(DungeonMap[sel] or DungeonMap['1-1'])
            print('[DEBUG] å°è¯•è¿›å…¥å‰¯æœ¬:', sel)
            pcall(function() EnterDungeon(dungeonId, difficulty) end)
        end
    end
end)

--================= å‰¯æœ¬å†…ç›‘æ§ ===================
function SetupInDungeon()
    spawn(function()
        -- ç­‰å¾… _G.KillauraKey æ•è·
        while not _G.KillauraKey do
            print("[SetupInDungeon] ç­‰å¾… _G.KillauraKey æ•è·ä¸­...")
            task.wait(1)
        end
        print("[SetupInDungeon] å·²æ•è·åˆ° Key:", _G.KillauraKey)

        -- å¦‚æœåœ¨å¤§å…ï¼Œç›´æ¥è¿”å›
        if Workspace:FindFirstChild('Lobby') then return end

        local healthPath, roundPath

        -- å°è¯•è·å–è¡€é‡å’Œå›åˆ UI
        local success, mainGui = pcall(function()
            return player:WaitForChild('PlayerGui'):WaitForChild('Main', 5)
        end)
        if success and mainGui then
            local home = mainGui:FindFirstChild('HomePage')
            if home then
                -- è¡€é‡è·¯å¾„
                local bottom = home:FindFirstChild('Bottom')
                if bottom then
                    local mainBottom = bottom:FindFirstChild('Main')
                    if mainBottom then
                        local health = mainBottom:FindFirstChild('Health')
                        if health then
                            local num = health:FindFirstChild('Num')
                            if num then
                                healthPath = num:FindFirstChild('Health')
                            end
                        end
                    end
                end

                -- å›åˆè·¯å¾„
                local endlessTop = home:FindFirstChild('EndlessTop')
                if endlessTop then
                    local top = endlessTop:FindFirstChild('Top')
                    if top then
                        roundPath = top:FindFirstChild('RoundTitle')
                    end
                end
            end
        end

        -- è‡ªåŠ¨åƒè¡€è¯
        if healthPath then
            local onCooldown = false
            healthPath:GetPropertyChangedSignal('Text'):Connect(function()
                if not Settings.HealthMonitorEnabled then return end
                local cur, max = string.match(healthPath.Text, '(%d+)%/(%d+)')
                if cur and max then
                    cur, max = tonumber(cur), tonumber(max)
                    if max > 0 and cur/max < 0.63 and not onCooldown then
                        onCooldown = true
                        pcall(function() TNet.FireServer('Potion_TryHealth') end)
                        task.delay(2, function() onCooldown = false end)
                    end
                end
            end)
        end

        -- å›åˆç›‘æ§
        if roundPath then
            roundPath:GetPropertyChangedSignal('Text'):Connect(function()
                local roundNum = tonumber(string.match(roundPath.Text, '%d+')) or 0
                UpdateRoundLabel(roundNum)
                if Settings.RoundTeleportEnabled and roundNum >= RoundThresholdValue then
                    print('[DEBUG] è¾¾åˆ°å›åˆé˜ˆå€¼ï¼Œé€€å‡ºå‰¯æœ¬')
                    pcall(function()
                        TNet.FireServer('Dungeon_Leave')
                        task.wait(1)
                        TeleportService:Teleport(72607172956362)
                    end)
                end
            end)
        end

        -- æŠ€èƒ½å¾ªç¯é‡Šæ”¾
        if Settings.AutoSkillEnabled then
            spawn(function()
                while Settings.AutoSkillEnabled do
                    if player.Character and player.PlayerGui and not Workspace:FindFirstChild("Lobby") then
                        for spell = 1, 5 do
                            pcall(function() 
                                TNet.FireServer("Skill_Release", spell) 
                            end)
                            task.wait(0.08)
                        end
                    end
                    task.wait(0.1)
                end
            end)
        end
    end)
end

-- å‡†å¤‡å¥½ç©å®¶ä»¥åå†æ‰§è¡Œ
spawn(function()
    SetupInDungeon()
end)


--================= é€€å‡ºå‰¯æœ¬æŒ‰é’® =================--
features:AddButton('é€€å‡ºå‰¯æœ¬', function()
    pcall(function() TeleportService:Teleport(72607172956362) end)
end)

features1:AddButton('é™„é­”å·¥å…·', function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/supleruckydior/test/refs/heads/main/dungeon/é™„é­”å·¥å…·"))()
end)
features1:AddLabel('è£…å¤‡å‡ºå”®æ•°é‡ä¸º1000')
-- æŒ‰é’®åŠŸèƒ½ï¼šæ‰¹é‡å‘é€ç¨€æœ‰åº¦ä¸º1çš„è£…å¤‡ ref
features1:AddButton("å‡ºå”®ç™½è‰²è£…å¤‡", function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local EquipmentShare = require(ReplicatedStorage.ClientBase.EquipmentShare)
    local items = (EquipmentShare.Data and EquipmentShare.Data.Bag and EquipmentShare.Data.Bag.Items) or {}
    local refsToSend = {}

    for _, item in ipairs(items) do
        local idStr = item and item.id and tostring(item.id)
        if idStr and #idStr >= 3 and tonumber(idStr:sub(3,3)) == 1 then
            table.insert(refsToSend, item.ref)
        end
    end

    if #refsToSend > 0 then
        local batchRefs = {}
        for i = 1, math.min(1000, #refsToSend) do
            table.insert(batchRefs, refsToSend[i])
        end

        pcall(function()
            TNet.FireServer("Equipment_Sell", batchRefs)
        end)

        print("å·²æ‰¹é‡å‘é€ " .. #batchRefs .. " ä¸ªç¨€æœ‰åº¦1è£…å¤‡çš„ ref")
    else
        warn("æœªæ‰¾åˆ°ç¨€æœ‰åº¦ä¸º1çš„è£…å¤‡")
    end
end)

features1:AddButton("å‡ºå”®ç»¿è‰²è£…å¤‡", function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local EquipmentShare = require(ReplicatedStorage.ClientBase.EquipmentShare)

    local items = (EquipmentShare.Data and EquipmentShare.Data.Bag and EquipmentShare.Data.Bag.Items) or {}
    local refsToSend = {}

    for _, item in ipairs(items) do
        local idStr = item and item.id and tostring(item.id)
        if idStr and #idStr >= 3 and tonumber(idStr:sub(3,3)) == 2 then
            table.insert(refsToSend, item.ref)
        end
    end

    if #refsToSend > 0 then
        local batchRefs = {}
        for i = 1, math.min(1000, #refsToSend) do
            table.insert(batchRefs, refsToSend[i])
        end

        pcall(function()
            TNet.FireServer("Equipment_Sell", batchRefs)
        end)

        print("å·²æ‰¹é‡å‘é€ " .. #batchRefs .. " ä¸ªç¨€æœ‰åº¦2è£…å¤‡çš„ ref")
    else
        warn("æœªæ‰¾åˆ°ç¨€æœ‰åº¦ä¸º2çš„è£…å¤‡")
    end
end)

features1:AddButton("å‡ºå”®è“è‰²è£…å¤‡", function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local EquipmentShare = require(ReplicatedStorage.ClientBase.EquipmentShare)

    local items = (EquipmentShare.Data and EquipmentShare.Data.Bag and EquipmentShare.Data.Bag.Items) or {}
    local refsToSend = {}

    for _, item in ipairs(items) do
        local idStr = item and item.id and tostring(item.id)
        if idStr and #idStr >= 3 and tonumber(idStr:sub(3,3)) == 3 then
            table.insert(refsToSend, item.ref)
        end
    end

    if #refsToSend > 0 then
        local batchRefs = {}
        for i = 1, math.min(1000, #refsToSend) do
            table.insert(batchRefs, refsToSend[i])
        end

        pcall(function()
                                TNet.FireServer("Equipment_Sell", batchRefs)
        end)

        print("å·²æ‰¹é‡å‘é€ " .. #batchRefs .. " ä¸ªç¨€æœ‰åº¦3è£…å¤‡çš„ ref")
    else
        warn("æœªæ‰¾åˆ°ç¨€æœ‰åº¦ä¸º3çš„è£…å¤‡")
    end
end)
features1:AddButton("å‡ºå”®ç´«è‰²ä»¥ä¸‹å…¨éƒ¨", function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local EquipmentShare = require(ReplicatedStorage.ClientBase.EquipmentShare)

    local items = (EquipmentShare.Data and EquipmentShare.Data.Bag and EquipmentShare.Data.Bag.Items) or {}
    local refsToSend = {}

    for _, item in ipairs(items) do
        local idStr = item and item.id and tostring(item.id)
        if idStr and #idStr >= 3 and tonumber(idStr:sub(3,3)) <= 3 then
            table.insert(refsToSend, item.ref)
        end
    end

    if #refsToSend > 0 then
        local batchRefs = {}
        for i = 1, math.min(1000, #refsToSend) do
            table.insert(batchRefs, refsToSend[i])
        end

        pcall(function()
                                TNet.FireServer("Equipment_Sell", batchRefs)
        end)

        print("å·²æ‰¹é‡å‘é€ " .. #batchRefs .. " ä¸ªç¨€æœ‰åº¦å°äº4è£…å¤‡çš„ ref")
    else
        warn("æœªæ‰¾åˆ°ç¨€æœ‰åº¦å°äº4çš„è£…å¤‡")
    end
end)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local EquipmentShare = require(ReplicatedStorage.ClientBase.EquipmentShare)
features1:AddLabel('æ³¨æ„dupeä¼šæ¸…ç©ºèƒŒåŒ…é‡Œæ‰€æœ‰ç‰©å“ï¼Œè¦ä¿ç•™çš„ä¸œè¥¿è®°å¾—æ”¾åœ¨äºŒæ¥¼ä»“åº“é‡Œ')
features1:AddSwitch("dupe", function(state)
    if state then
        print("[Loop] å¾ªç¯å¼€å§‹")
        if not _G.PacketLoop then
            _G.PacketLoopRunning = true
            _G.PacketLoop = task.spawn(function()
                while _G.PacketLoopRunning do

                    -- å…ˆå‘ y 100 æ¬¡
                    for i = 1, 100 do
                        if not _G.PacketLoopRunning then break end
                        pcall(function()
                            TNetSent:FireServer("y", 100)
                        end)
                        task.wait(0.1)
                    end
                    if not _G.PacketLoopRunning then break end

                    -- å‘ä¸€æ¬¡ Backpack_EquipBest
                    pcall(function()
                        TNet.FireServer("Backpack_EquipBest")
                    end)
                    task.wait(0.1)

                    -- è·å–èƒŒåŒ…ç‰©å“
                    local items = (EquipmentShare.Data and EquipmentShare.Data.Bag and EquipmentShare.Data.Bag.Items) or {}
                    print("èƒŒåŒ…ç‰©å“æ•°é‡:", #items)

                    -- å¦‚æœèƒŒåŒ…è¶…è¿‡300ä¸ªç‰©å“ï¼Œè¿ç»­å‡ºå”®ç›´åˆ°æ¸…ç©º
                    if #items > 300 then
                        print("å¼€å§‹æ‰¹é‡å‡ºå”®è£…å¤‡")
                        while #items > 0 and _G.PacketLoopRunning do
                            for _, item in ipairs(items) do
                                if not _G.PacketLoopRunning then break end
                                local refToSend = item.ref or 1052
                                pcall(function()
                                    TNet.FireServer("Equipment_Sell", { refToSend })
                                end)
                            end
                            task.wait(2)
                            items = (EquipmentShare.Data and EquipmentShare.Data.Bag and EquipmentShare.Data.Bag.Items) or {}
                            print("å‰©ä½™èƒŒåŒ…ç‰©å“æ•°é‡:", #items)
                        end
                        print("è£…å¤‡å·²æ¸…ç©º")
                    end

                end
                _G.PacketLoop = nil
                print("[Loop] å·²ç»“æŸ")
            end)
        end
    else
        print("[Loop] å¾ªç¯å·²å…³é—­")
        _G.PacketLoopRunning = false
        _G.PacketLoop = nil
    end
end)


