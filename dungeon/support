--================= 配置 =================--
local TARGET_GAME_ID_1 = 113080689665370
local TARGET_GAME_ID_2 = 120876398824321
local TARGET_GAME_ID_3 = 72607172956362
if game.PlaceId ~= TARGET_GAME_ID_1 and game.PlaceId ~= TARGET_GAME_ID_2 and game.PlaceId ~= TARGET_GAME_ID_3 then
    print("⚠️ wrong game")
    return
end

if not game:IsLoaded() then
    game.Loaded:Wait()
end
wait(3)
--================= 加载UI库 =================--
local library = loadstring(
    game:HttpGet(
        'https://raw.githubusercontent.com/supleruckydior/test/refs/heads/main/menu.json',
        true
    )
)()

-- 防AFK
local AntiAFK = game:GetService('VirtualUser')
game.Players.LocalPlayer.Idled:Connect(function()
    AntiAFK:CaptureController()
    AntiAFK:ClickButton2(Vector2.new())
    wait(2)
end)

--================= 服务引用 =================--
local Players = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local ReplicatedFirst = game:GetService('ReplicatedFirst')
local Workspace = game:GetService('Workspace')
local HttpService = game:GetService('HttpService')
local TeleportService = game:GetService('TeleportService')

local player = Players.LocalPlayer
local TNet = require(ReplicatedFirst.Component.TNet)
local Config = require(ReplicatedStorage.Config)

--================= 设置保存 =================--
local SettingsFile = 'DungeonSettings_'..player.Name..'.json'
local Settings = {
    AutoDungeonEnabled = false,
    SelectedDungeon = '1-1',
    AutoSkillEnabled = false,
    HealthMonitorEnabled = true,
    RoundTeleportEnabled = true,
    RoundTeleportThreshold = 55,
}

pcall(function()
    if isfile and isfile(SettingsFile) then
        Settings = HttpService:JSONDecode(readfile(SettingsFile))
    end
end)

local function SaveSettings()
    if writefile then
        writefile(SettingsFile, HttpService:JSONEncode(Settings))
    end
end

--================= Dungeon 配置 =================--
local DungeonOptions = {
    '1-1','1-2','1-3','2-1','2-2','2-3',
    '3-1','3-2','3-3','4-1','4-2','4-3',
    'endless-1','endless-16','endless-31','endless-46','endless-61','',''
}

local DungeonMap = {
    ['1-1']={1300001,1},['1-2']={1300001,2},['1-3']={1300001,3},
    ['2-1']={1300002,1},['2-2']={1300002,2},['2-3']={1300002,3},
    ['3-1']={1300003,1},['3-2']={1300003,2},['3-3']={1300003,3},
    ['4-1']={1300004,1},['4-2']={1300004,2},['4-3']={1300004,3},
    ['endless-1']={3200001,1},['endless-16']={3200001,16},
    ['endless-31']={3200001,31},['endless-46']={3200001,46},
    ['endless-61']={3200001,61}
}

--================= 进入副本逻辑 =================--
local dungeonLock = false

local function EnterDungeon(dungeonId, difficulty)
    if dungeonLock then
        print('[DEBUG] 已经在进入副本锁定状态，跳过')
        return
    end
    dungeonLock = true
    task.delay(10, function() dungeonLock = false end)

    repeat task.wait() until Workspace:FindFirstChild('Lobby')
    local lobby = Workspace:FindFirstChild('Lobby')

    local function FindIdleTable()
        local lobbySection = Workspace.Lobby:FindFirstChild('\229\140\185\233\133\141\229\140\186')
        if not lobbySection then return nil end
        for i=4,#lobbySection:GetChildren() do
            local tableObj = lobbySection:GetChildren()[i]
            local match = tableObj:FindFirstChild('Match')
            if match and match:FindFirstChild('BillboardGui') then
                local idle = match.BillboardGui:FindFirstChild('Idle')
                if idle and idle.Visible then return match end
            end
        end
        return nil
    end

    local tableObj = FindIdleTable()
    if not tableObj then
        print('[DEBUG] 没有找到空闲桌子')
        dungeonLock = false
        return
    end

    if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') then
        print('[DEBUG] 玩家角色或 HumanoidRootPart 未就绪')
        dungeonLock = false
        return
    end

    print('[DEBUG] 移动到桌子:', tableObj.Parent.Name)
    player.Character.HumanoidRootPart.CFrame = CFrame.new(tableObj.Position)
    task.wait(0.6)

    print('[DEBUG] 选择副本 ID:', dungeonId, '难度:', difficulty)
    pcall(function() TNet.FireServer('Dungeon_Select', dungeonId, difficulty) end)
    task.wait(0.1)

    print('[DEBUG] 开始副本')
    pcall(function() TNet.FireServer('Dungeon_StartParty') end)

    task.delay(2, function()
        dungeonLock = false
        print('[DEBUG] 解除进入副本锁定')
    end)
end

--================= UI 初始化 =================--
local window = library:AddWindow('DUNGEON LOOTIFY v1.0',{main_color=Color3.fromRGB(41,74,122), min_size=Vector2.new(530,400)})
local features = window:AddTab('功能')

-- 自动进入副本开关
local autoJoinSwitch = features:AddSwitch('自动进入副本', function(bool)
    Settings.AutoDungeonEnabled = bool
    SaveSettings()
end)
if autoJoinSwitch.Set then autoJoinSwitch:Set(Settings.AutoDungeonEnabled) end

-- 当前选择关卡
local selectedLabel = features:AddLabel('当前选择: ' .. Settings.SelectedDungeon)
local dungeonDropdown = features:AddDropdown('选择地下城', function(text)
    local cleaned = text:match('^%s*(.-)%s*$') or text
    if cleaned ~= '' then
        Settings.SelectedDungeon = cleaned
        SaveSettings()
        if selectedLabel.Set then 
            selectedLabel:Set('当前选择: ' .. cleaned)
        end
    end
end)
for _, name in ipairs(DungeonOptions) do
    dungeonDropdown:Add(name)
end
if dungeonDropdown.Set then
    dungeonDropdown:Set(Settings.SelectedDungeon)
end

-- 自动吃血药开关
local autoPotionSwitch = features:AddSwitch('自动吃血药', function(bool)
    Settings.HealthMonitorEnabled = bool
    SaveSettings()
end)
if autoPotionSwitch.Set then autoPotionSwitch:Set(Settings.HealthMonitorEnabled) end

-- 技能循环释放开关
local autoSkillSwitch = features:AddSwitch('技能循环释放', function(bool)
    Settings.AutoSkillEnabled = bool
    SaveSettings()
end)
if autoSkillSwitch.Set then autoSkillSwitch:Set(Settings.AutoSkillEnabled) end
-- edndless循环释放开关
features:AddSwitch('自动选择 Endless', function(state)
    Settings.AutoEndlessChoose = state
    SaveSettings()

    -- 确保只注册一次监听
    if not _G.AutoEndlessListenerRegistered then
        _G.AutoEndlessListenerRegistered = true

        -- 全局注册监听
        TNet.SetEvent("Endless_ShowPlayerUpgrade", function(upgradeList)
            print("⚠️ 收到 Endless_ShowPlayerUpgrade 下发数据:")
            for i, id in ipairs(upgradeList) do
                local upgradeInfo = Config.Endless.UpgradeList[id]
                local name = upgradeInfo and upgradeInfo.name or "未知"
                local desc = upgradeInfo and upgradeInfo.description or "无描述"
                print(string.format("Index[%d] -> ID: %d, 名称: %s, 描述: %s", i, id, name, desc))
            end

            if Settings.AutoEndlessChoose then
                local chosenIndex = nil
                -- 优先找名字包含 Crystal（忽略大小写）
                for i, id in ipairs(upgradeList) do
                    local upgradeInfo = Config.Endless.UpgradeList[id]
                    if upgradeInfo and string.find(upgradeInfo.name:lower(), "crystal") then
                        chosenIndex = i
                        break
                    end
                end

                -- 如果没有找到，则选 ID 最后一个数字最大的
                if not chosenIndex then
                    local maxLastDigit = -1
                    for i, id in ipairs(upgradeList) do
                        local lastDigit = tonumber(tostring(id):sub(-1)) or 0
                        if lastDigit > maxLastDigit then
                            maxLastDigit = lastDigit
                            chosenIndex = i
                        end
                    end
                end

                -- 发送选择并隐藏界面
                pcall(function()
                    print("[AutoEndless] 自动选择 Index:", chosenIndex)
                    TNet.FireServer("Endless_PlayerChoose", chosenIndex)

                    -- 选择后隐藏 Endless 界面
                    local gui = player:FindFirstChild("PlayerGui")
                    if gui then
                        local endlessUI = gui:FindFirstChild("Main")
                            and gui.Main:FindFirstChild("Func")
                            and gui.Main.Func:FindFirstChild("EndlessChoose")
                        if endlessUI then
                            endlessUI.Visible = false
                            print("[AutoEndless] 已隐藏 Endless 选择界面")
                        end
                    end
                end)
            end
        end)
    end
end):Set(Settings.AutoEndlessChoose)



-- 回合检测开关
local roundCheckSwitch = features:AddSwitch('回合检查', function(bool)
    Settings.RoundTeleportEnabled = bool
    SaveSettings()
end)
if roundCheckSwitch.Set then roundCheckSwitch:Set(Settings.RoundTeleportEnabled) end

--================= 回合阈值与显示 =================--
if type(Settings.RoundTeleportThreshold) ~= 'number' then
    Settings.RoundTeleportThreshold = 55
    SaveSettings()
end
local RoundThresholdValue = Settings.RoundTeleportThreshold
-- 回合显示Label
local roundLabel = features:AddLabel('回合: 0 / ' .. RoundThresholdValue)

-- 刷新函数
local function UpdateRoundLabel(currentRound)
    currentRound = currentRound or 0
    roundLabel.Text = '回合: ' .. currentRound .. ' / ' .. RoundThresholdValue
end
-- 添加阈值显示更新函数
local function UpdateThresholdDisplay()
    RoundThresholdValue = Settings.RoundTeleportThreshold
    -- 更新回合显示的阈值部分
    local currentRound = tonumber(string.match(roundLabel.Text, '回合: (%d+)') or 0)
    roundLabel.Text = '回合: ' .. currentRound .. ' / ' .. RoundThresholdValue
    print('[DEBUG] 阈值更新为:', RoundThresholdValue)
end
-- 设置退出回合阈值输入框
local thresholdInput = features:AddTextBox('设置退出回合阈值', function(text)
    local num = tonumber(text)
    if num and num > 0 then
        Settings.RoundTeleportThreshold = num
        SaveSettings()
        UpdateThresholdDisplay()
        print('[DEBUG] 阈值设置为:', num)
    else
        -- 输入无效，直接修改Text属性恢复原值
        thresholdInput.Text = tostring(Settings.RoundTeleportThreshold)
        print('[WARN] 无效输入，已恢复为:', Settings.RoundTeleportThreshold)
    end
end)
thresholdInput.Text = tostring(Settings.RoundTeleportThreshold)
print('[DEBUG] 输入框初始值设置为:', Settings.RoundTeleportThreshold)
-- 主循环刷新回合 Label
spawn(function()
    while true do
        task.wait(0.5)
        local currentRound = 0
        pcall(function()
            local roundGui = player.PlayerGui:FindFirstChild('Main')
                and player.PlayerGui.Main:FindFirstChild('HomePage')
                and player.PlayerGui.Main.HomePage:FindFirstChild('EndlessTop')
                and player.PlayerGui.Main.HomePage.EndlessTop:FindFirstChild('Top')
                and player.PlayerGui.Main.HomePage.EndlessTop.Top:FindFirstChild('RoundTitle')
            if roundGui then
                currentRound = tonumber(string.match(roundGui.Text, '%d+')) or 0
            end
        end)
        UpdateRoundLabel(currentRound)
    end
end)


--================= 自动进入副本循环 =================--
spawn(function()
    while true do
        task.wait(5)
        if not Settings.AutoDungeonEnabled then continue end
        if Workspace:FindFirstChild('Lobby') then
            local sel = Settings.SelectedDungeon or '1-1'
            local dungeonId, difficulty = unpack(DungeonMap[sel] or DungeonMap['1-1'])
            print('[DEBUG] 尝试进入副本:', sel)
            pcall(function() EnterDungeon(dungeonId, difficulty) end)
        end
    end
end)

--================= 副本内监控 ===================
local function SetupInDungeon()
    if Workspace:FindFirstChild('Lobby') then return end

    local healthPath, roundPath
    pcall(function()
        local mainGui = player:WaitForChild('PlayerGui'):WaitForChild('Main', 5)
        if mainGui then
            local home = mainGui:WaitForChild('HomePage', 3)
            if home then
                local bottom = home:WaitForChild('Bottom', 3)
                if bottom then
                    local mainBottom = bottom:WaitForChild('Main', 3)
                    if mainBottom then
                        local health = mainBottom:WaitForChild('Health', 3)
                        if health then
                            local num = health:WaitForChild('Num', 3)
                            if num then
                                healthPath = num:WaitForChild('Health', 3)
                            end
                        end
                    end
                end
                local endlessTop = home:FindFirstChild('EndlessTop')
                if endlessTop then
                    local top = endlessTop:WaitForChild('Top', 3)
                    if top then
                        roundPath = top:WaitForChild('RoundTitle', 3)
                    end
                end
            end
        end
    end)

    -- 自动吃血药
    if healthPath then
        local onCooldown = false
        healthPath:GetPropertyChangedSignal('Text'):Connect(function()
            if not Settings.HealthMonitorEnabled then return end
            local cur, max = string.match(healthPath.Text, '(%d+)%/(%d+)')
            if cur and max then
                cur, max = tonumber(cur), tonumber(max)
                if max > 0 and cur/max < 0.63 and not onCooldown then
                    onCooldown = true
                    pcall(function() TNet.FireServer('Potion_TryHealth') end)
                    task.delay(2, function() onCooldown = false end)
                end
            end
        end)
    end

    -- 回合监控
    if roundPath then
        roundPath:GetPropertyChangedSignal('Text'):Connect(function()
            local roundNum = tonumber(string.match(roundPath.Text, '%d+')) or 0
            UpdateRoundLabel(roundNum)
            if Settings.RoundTeleportEnabled and roundNum >= RoundThresholdValue then
                print('[DEBUG] 达到回合阈值，退出副本')
                pcall(function()
                    TNet.FireServer('Dungeon_Leave')
                    task.wait(1)
                    TeleportService:Teleport(121727847541143)
                end)
            end
        end)
    end

    -- 技能循环释放
    if Settings.AutoSkillEnabled then
        spawn(function()
            local skillCooldown = {[1]=false,[2]=false,[3]=false,[4]=false}
            while true do
                task.wait(0.5)
                if Settings.AutoSkillEnabled and player.Character and player.PlayerGui then
                    if not Workspace:FindFirstChild('Lobby') then
                        for spell=1,5 do
                            if not skillCooldown[spell] then
                                skillCooldown[spell] = true
                                pcall(function() TNet.FireServer('Skill_Release', spell) end)
                                task.delay(1, function() skillCooldown[spell] = false end)
                                task.wait(0.2)
                            end
                        end
                    end
                end
            end
        end)
    end
end

spawn(function()
    repeat task.wait() until player.Character and player:FindFirstChild('PlayerGui')
    SetupInDungeon()
end)

--================= 退出副本按钮 =================--
features:AddButton('退出副本', function()
    pcall(function() TeleportService:Teleport(121727847541143) end)
end)
