--================= ÈÖçÁΩÆ =================--
local TARGET_GAME_ID_1 = 113080689665370
local TARGET_GAME_ID_2 = 120876398824321
local TARGET_GAME_ID_3 = 72607172956362
if game.PlaceId ~= TARGET_GAME_ID_1 and game.PlaceId ~= TARGET_GAME_ID_2 and game.PlaceId ~= TARGET_GAME_ID_3 then
    print("‚ö†Ô∏è wrong game")
    return
end

if not game:IsLoaded() then
    game.Loaded:Wait()
end
wait(3)
--================= Âä†ËΩΩUIÂ∫ì =================--
local library = loadstring(
    game:HttpGet(
        'https://raw.githubusercontent.com/supleruckydior/test/refs/heads/main/menu.json',
        true
    )
)()

-- Èò≤AFK
local AntiAFK = game:GetService('VirtualUser')
game.Players.LocalPlayer.Idled:Connect(function()
    AntiAFK:CaptureController()
    AntiAFK:ClickButton2(Vector2.new())
    wait(2)
end)

--================= ÊúçÂä°ÂºïÁî® =================--
local Players = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local ReplicatedFirst = game:GetService('ReplicatedFirst')
local Workspace = game:GetService('Workspace')
local HttpService = game:GetService('HttpService')
local TeleportService = game:GetService('TeleportService')
local player = Players.LocalPlayer
local TNet = require(ReplicatedFirst.Component.TNet)
local Config = require(ReplicatedStorage.Config)
local RunService = game:GetService("RunService")
local TNetSent = ReplicatedStorage:WaitForChild("TNetSent")
--================= ËÆæÁΩÆ‰øùÂ≠ò =================--
local SettingsFile = 'DungeonSettings_'..player.Name..'.json'
local Settings = {
    AutoDungeonEnabled = false,
    SelectedDungeon = '1-1',
    AutoSkillEnabled = false,
    HealthMonitorEnabled = true,
    RoundTeleportEnabled = true,
    RoundTeleportThreshold = 55,
    AutoAttackEnabled = false,  -- Êñ∞Â¢ûÁöÑÂäüËÉΩ
}

pcall(function()
    if isfile and isfile(SettingsFile) then
        Settings = HttpService:JSONDecode(readfile(SettingsFile))
    end
end)

local function SaveSettings()
    if writefile then
        writefile(SettingsFile, HttpService:JSONEncode(Settings))
    end
end

--================= Dungeon ÈÖçÁΩÆ =================--
local DungeonOptions = {
    '1-1','1-2','1-3','2-1','2-2','2-3',
    '3-1','3-2','3-3','4-1','4-2','4-3',
    'endless-1','endless-16','endless-31','endless-46','endless-61','',''
}

local DungeonMap = {
    ['1-1']={1300001,1},['1-2']={1300001,2},['1-3']={1300001,3},
    ['2-1']={1300002,1},['2-2']={1300002,2},['2-3']={1300002,3},
    ['3-1']={1300003,1},['3-2']={1300003,2},['3-3']={1300003,3},
    ['4-1']={1300004,1},['4-2']={1300004,2},['4-3']={1300004,3},
    ['endless-1']={3200001,1},['endless-16']={3200001,16},
    ['endless-31']={3200001,31},['endless-46']={3200001,46},
    ['endless-61']={3200001,61}
}

--================= ËøõÂÖ•ÂâØÊú¨ÈÄªËæë =================--
local dungeonLock = false

local function EnterDungeon(dungeonId, difficulty)
    if dungeonLock then
        print('[DEBUG] Â∑≤ÁªèÂú®ËøõÂÖ•ÂâØÊú¨ÈîÅÂÆöÁä∂ÊÄÅÔºåË∑≥Ëøá')
        return
    end
    dungeonLock = true
    task.delay(10, function() dungeonLock = false end)

    repeat task.wait() until Workspace:FindFirstChild('Lobby')
    local lobby = Workspace:FindFirstChild('Lobby')

    local function FindIdleTable()
        local lobbySection = Workspace.Lobby:FindFirstChild('\229\140\185\233\133\141\229\140\186')
        if not lobbySection then return nil end
        for i=4,#lobbySection:GetChildren() do
            local tableObj = lobbySection:GetChildren()[i]
            local match = tableObj:FindFirstChild('Match')
            if match and match:FindFirstChild('BillboardGui') then
                local idle = match.BillboardGui:FindFirstChild('Idle')
                if idle and idle.Visible then return match end
            end
        end
        return nil
    end

    local tableObj = FindIdleTable()
    if not tableObj then
        print('[DEBUG] Ê≤°ÊúâÊâæÂà∞Á©∫Èó≤Ê°åÂ≠ê')
        dungeonLock = false
        return
    end

    if not player.Character or not player.Character:FindFirstChild('HumanoidRootPart') then
        print('[DEBUG] Áé©ÂÆ∂ËßíËâ≤Êàñ HumanoidRootPart Êú™Â∞±Áª™')
        dungeonLock = false
        return
    end

    print('[DEBUG] ÁßªÂä®Âà∞Ê°åÂ≠ê:', tableObj.Parent.Name)
    player.Character.HumanoidRootPart.CFrame = CFrame.new(tableObj.Position)
    task.wait(0.6)

    print('[DEBUG] ÈÄâÊã©ÂâØÊú¨ ID:', dungeonId, 'ÈöæÂ∫¶:', difficulty)
    pcall(function() TNet.FireServer('Dungeon_Select', dungeonId, difficulty) end)
    task.wait(0.1)

    print('[DEBUG] ÂºÄÂßãÂâØÊú¨')
    pcall(function() TNet.FireServer('Dungeon_StartParty') end)

    task.delay(2, function()
        dungeonLock = false
        print('[DEBUG] Ëß£Èô§ËøõÂÖ•ÂâØÊú¨ÈîÅÂÆö')
    end)
end

--================= UI ÂàùÂßãÂåñ =================--
local window = library:AddWindow('DUNGEON LOOTIFY v2.7',{main_color=Color3.fromRGB(41,74,122), min_size=Vector2.new(530,490)})
local features = window:AddTab('ÂäüËÉΩ')
local features1 = window:AddTab('ÊùÇÈ°π')
-- Ëá™Âä®ËøõÂÖ•ÂâØÊú¨ÂºÄÂÖ≥
local autoJoinSwitch = features:AddSwitch('Ëá™Âä®ËøõÂÖ•ÂâØÊú¨', function(bool)
    Settings.AutoDungeonEnabled = bool
    SaveSettings()
end)
if autoJoinSwitch.Set then autoJoinSwitch:Set(Settings.AutoDungeonEnabled) end

-- ÂΩìÂâçÈÄâÊã©ÂÖ≥Âç°
local selectedLabel = features:AddLabel('ÂΩìÂâçÈÄâÊã©: ' .. Settings.SelectedDungeon)
local dungeonDropdown = features:AddDropdown('ÈÄâÊã©Âú∞‰∏ãÂüé', function(text)
    local cleaned = text:match('^%s*(.-)%s*$') or text
    if cleaned ~= '' then
        Settings.SelectedDungeon = cleaned
        SaveSettings()
        if selectedLabel.Set then 
            selectedLabel:Set('ÂΩìÂâçÈÄâÊã©: ' .. cleaned)
        end
    end
end)
for _, name in ipairs(DungeonOptions) do
    dungeonDropdown:Add(name)
end
if dungeonDropdown.Set then
    dungeonDropdown:Set(Settings.SelectedDungeon)
end
-- Ê≠¶Âô®ÈÖçÁΩÆÈÄâÈ°π
local weaponOptions = {
    ["SwordShield"] = "SwordShield1",
    ["DuoSword"]    = "Duosword1",
    ["Wood"]        = "Wood1"
}

-- Â¶ÇÊûúÊ≤°ËÆæÁΩÆËøáÔºåÂ∞±ÁªôÈªòËÆ§ÂÄº
if not Settings.SelectedWeapon then
    Settings.SelectedWeapon = "SwordShield"
    SaveSettings()
end

-- Ê≠¶Âô®‰∏ãÊãâËèúÂçï
local weaponDropdown = features:AddDropdown("ÈÄâÊã©Ê≠¶Âô®", function(choice)
    if weaponOptions[choice] then
        Settings.SelectedWeapon = choice
        SaveSettings()
        print("[Killaura] Â∑≤ÂàáÊç¢Ê≠¶Âô®:", choice, "Âä®Áîª:", weaponOptions[choice])
    end
end)

-- ÂàùÂßãÂåñ‰∏ãÊãâÊ°ÜÊòæÁ§∫‰∏äÊ¨°‰øùÂ≠òÁöÑÂÄº
for weaponName, _ in pairs(weaponOptions) do
    weaponDropdown:Add(weaponName)
end
if weaponDropdown.Set then
    weaponDropdown:Set(Settings.SelectedWeapon)
end
-- ================= killaura Âà§Êñ≠ÈÄªËæë =================
-- ÂÖ®Â±ÄÂèòÈáè
_G.KillauraKey = nil       -- ÂºÄÂ±Ä‰∏∫ nil
_G.KillauraReady = false   -- ÊòØÂê¶ÂèØ‰ª•ÂêØÂä® killaura Âíå SetupInDungeon

local function sendWeaponOnHit()
    local args = {
        Workspace:GetServerTimeNow(), -- timestamp Âõ∫ÂÆöÊàñÂΩìÂâçÊó∂Èó¥
        1,
        "SwordShield",
        {
            hitNum = 0,
            onHitAnimName = "SwordShield1",
            hrtCF = CFrame.fromMatrix(
                Vector3.new(-332.72, 1003.56, 1.07),
                Vector3.new(0.52, 0.00, 0.85),
                Vector3.new(0.00, 1.00, 0.00),
                Vector3.new(-0.85, 0.00, 0.52)
            )
        }
    }
    TNet.FireServer("Weapon_OnHit", unpack(args))
    print("[DEBUG] Weapon_OnHit ÂèëÈÄÅÊàêÂäü")
end

-- Hook TNetSentÔºåÂè™ÊçïËé∑ÂÆ¢Êà∑Á´ØÂèëÂá∫ÁöÑÁâπÂÆö‰∫ã‰ª∂
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if self == TNetSent and method == "FireServer" then
        if type(args[1]) == "string" and type(args[3]) == "number" then
            print("[DEBUG] ÊçïËé∑ TNetSent:", args[1], args[3])
            _G.KillauraKey = args[1]          -- Êõ¥Êñ∞ Key
            _G.KillauraReady = true           -- ÂèØ‰ª•ÂêØÂä®ÈÄªËæë

            -- ÊçïËé∑ÂêéÁ´ãÂç≥ËøòÂéü hook
            hookmetamethod(game, "__namecall", oldNamecall)

            print("[DEBUG] Hook Â∑≤ËøòÂéü")
        end
    end

    return oldNamecall(self, ...)
end)

-- Âæ™ÁéØÂèëÈÄÅ Weapon_OnHit Áõ¥Âà∞ÊçïËé∑ Key
spawn(function()
    while not _G.KillauraKey do
        sendWeaponOnHit()
        task.wait(5) -- ËäÇÊµÅÔºåÈÅøÂÖçÂ¥©Ê∫É
    end
end)

-- Á≠âÂæÖ Key ÂêéÂêØÂä®ÈÄªËæë
spawn(function()
    while not _G.KillauraReady do
        task.wait(0.1)
    end

    print("[DEBUG] Key ÊçïËé∑ÂÆåÊàêÔºåÂêØÂä®ÈÄªËæë")

end)




-- ================= killaura ÂºÄÂÖ≥ =================
features:AddSwitch("killaura", function(state)
    Settings.AutoAttackEnabled = state
    SaveSettings()

    if state then
        print("[AutoAttack] Ëá™Âä®ÊîªÂáªÂ∑≤ÂºÄÂêØ")

        -- ÊúçÂä°Ëé∑Âèñ
        local Workspace = game:GetService("Workspace")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RunService = game:GetService("RunService")

        local TNetSent = ReplicatedStorage:WaitForChild("TNetSent")

        local cycleIndex, attackId = 1, 0
        local lastPositions = {}

        -- Á≠âÂæÖ _G.KillauraKey ÊçïËé∑
        while not _G.KillauraKey do
            task.wait(0.1)
        end
        print("[AutoAttack] ÊçïËé∑Âà∞ KillauraKey =", _G.KillauraKey)

        local function getServerTime()
            return Workspace:GetServerTimeNow()
        end

        local function attack(enemy, cf)
            local weaponName = Settings.SelectedWeapon
            local animName   = weaponOptions[weaponName] or "SwordShield1"

            local args = {
                _G.KillauraKey, -- ÊõøÊç¢ Bd ‰∏∫ÊçïËé∑Âà∞ÁöÑ Key
                attackId,
                getServerTime(),
                cycleIndex,
                weaponName,
                {
                    hitNum = math.random(0,5),
                    onHitAnimName = animName,
                    hrtCF = cf
                }
            }
            TNetSent:FireServer(unpack(args))

            cycleIndex = cycleIndex + 1
            if cycleIndex > 1 then cycleIndex = 1 end
            attackId = attackId + 1
        end

        local function getPredictedCFrame(enemy, dt)
            local root = enemy:FindFirstChild("HumanoidRootPart")
            if not root then return nil end
            local lastPos = lastPositions[enemy] or root.Position
            local currentPos = root.Position
            local velocity = (currentPos - lastPos) / dt
            local predictionFactor = 0.1
            local predictedPos = currentPos + velocity * predictionFactor
            lastPositions[enemy] = currentPos
            return CFrame.new(predictedPos)
        end

local IgnoreList = {
    ["84f0df6486bd4efa"] = true
}

local function getClosestEnemy(dt)
    local closest, shortestDist = nil, math.huge
    local playerPos = workspace.CurrentCamera and workspace.CurrentCamera.CFrame.Position or Vector3.new(0,0,0)

    for _, room in ipairs(Workspace:GetChildren()) do
        if room:IsA("Model") and (room:FindFirstChild("EnemySpawnPoint") or room:FindFirstChild("EnemySpawnArea")) then
            for _, obj in ipairs(room:GetChildren()) do
                if obj:IsA("Model") 
                   and obj:FindFirstChild("HumanoidRootPart") 
                   and not IgnoreList[obj.Name] then   -- üîπË∑≥ËøáÂøΩÁï•ÁõÆÊ†á

                    local root = obj.HumanoidRootPart
                    local isBoss = false
                    local typeAttr = obj:GetAttribute("Type")
                    if typeAttr and string.find(string.lower(typeAttr), "boss") then
                        isBoss = true
                    end

                    local healthTextObj = root:FindFirstChild("Health") 
                        and root.Health:FindFirstChild("Canvas") 
                        and root.Health.Canvas:FindFirstChild("Health") 
                        and root.Health.Canvas.Health:FindFirstChild("HealthText")
                    local healthNum = healthTextObj and tonumber(healthTextObj.Text:match("%d+")) or 0

                    if isBoss or (healthNum and healthNum > 0) then
                        local dist = (root.Position - playerPos).Magnitude
                        if dist < shortestDist then
                            shortestDist, closest = dist, obj
                        end
                    end
                end
            end
        end
    end

    if closest then
        return getPredictedCFrame(closest, dt), closest
    end
    return nil, nil
end

        -- ‰∏ªÂæ™ÁéØ
        if not _G.AutoAttackConnection then
            _G.AutoAttackConnection = RunService.Heartbeat:Connect(function(dt)
                if not Settings.AutoAttackEnabled then return end
                local cf, enemy = getClosestEnemy(dt)
                if cf and enemy then
                    attack(enemy, cf)
                end
            end)
        end

    else
        print("[AutoAttack] Ëá™Âä®ÊîªÂáªÂ∑≤ÂÖ≥Èó≠")
        if _G.AutoAttackConnection then
            _G.AutoAttackConnection:Disconnect()
            _G.AutoAttackConnection = nil
        end
    end
end):Set(Settings.AutoAttackEnabled)




-- ================= Ê®°ÊãüÊîªÂáªÂºÄÂÖ≥ =================
local function shiftKey(key)
    if #key == 0 then return key end
    local result = key:sub(1,1) -- ‰øùÁïôÁ¨¨‰∏Ä‰∏™Â≠óÁ¨¶‰∏çÂèò
    for i = 2, #key do
        local c = key:sub(i,i)
        local byte = c:byte()
        if byte >= 65 and byte <= 90 then -- Â§ßÂÜô A-Z
            result = result .. string.char(65 + (byte - 65 + 1) % 26)
        elseif byte >= 97 and byte <= 122 then -- Â∞èÂÜô a-z
            result = result .. string.char(97 + (byte - 97 + 1) % 26)
        else
            result = result .. c -- ÈùûÂ≠óÊØç‰øùÊåÅ‰∏çÂèò
        end
    end
    return result
end


local attackSwitch = features:AddSwitch("Âà∑ÊäÄËÉΩÊó†ÂÜ∑Âç¥", function(state)
    Settings.SimulatedAttackEnabled = state
    SaveSettings()
    if state then
        if not _G.SimAttackThread then
            _G.SimAttackThread = spawn(function()
                while not _G.KillauraKey do
                    print("[SimulatedAttack] Á≠âÂæÖ _G.KillauraKey ÊçïËé∑‰∏≠...")
                    task.wait(1)
                end
                print("[SimulatedAttack] Â∑≤ÊçïËé∑Âà∞ Key:", _G.KillauraKey)
                local newKey = shiftKey(_G.KillauraKey) -- ËøôÈáåÊääÊØè‰∏™Â≠óÊØç+1
                print("[SimulatedAttack] Â∑≤ÊçïËé∑Âà∞ newKey:", newKey)

                while Settings.SimulatedAttackEnabled do
                    task.wait(0.05)
                    local weaponName = Settings.SelectedWeapon
                    local animName   = weaponOptions[weaponName] or "SwordShield1"
                    local simulatedCFrame = CFrame.new(Vector3.new(10, 5, -20))

                    pcall(function()
                        TNet.FireServer(newKey, 1, Workspace:GetServerTimeNow(), 1, weaponName, {
                            hitNum = 0,
                            onHitAnimName = animName,
                            hrtCF = simulatedCFrame
                        })
                    end)
                end
            end)
        end
    else
        Settings.SimulatedAttackEnabled = false
        _G.SimAttackThread = nil
    end
end)


-- ÂàùÂßãÂåñÂºÄÂÖ≥Áä∂ÊÄÅ
if attackSwitch.Set then
    attackSwitch:Set(Settings.SimulatedAttackEnabled or false)
end


-- ÂàùÂßãÂåñÁä∂ÊÄÅ
if attackSwitch.Set then
    attackSwitch:Set(Settings.SimulatedAttackEnabled or false)
end


features:AddSwitch("Ëá™Âä®ÈáçËØïÂâØÊú¨", function(state)
    Settings.AutoDungeonRetry = state
    SaveSettings()

    if state then
        print("[AutoRetry] Ëá™Âä®ÂâØÊú¨ÈáçËØïÂ∑≤ÂºÄÂêØ")

        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        local ReplicatedFirst = game:GetService("ReplicatedFirst")
        local TNet = require(ReplicatedFirst.Component.TNet)

        -- Âæ™ÁéØÊ£ÄÊµã
        spawn(function()
            while Settings.AutoDungeonRetry do
                task.wait(2)
                local success, gui = pcall(function()
                    return player.PlayerGui.Main.Func.DungeonObtain
                end)
                if success and gui and gui.Visible then
                    print("[AutoRetry] Ê£ÄÊµãÂà∞ DungeonObtain ÂèØËßÅÔºåÂèëÈÄÅ Dungeon_RetryCmd")
                    pcall(function()
                        TNet.FireServer("Dungeon_RetryCmd")
                    end)
                    break -- ‚úÖ ÂèëÈÄÅ‰∏ÄÊ¨°ÂêéÁõ¥Êé•ÈÄÄÂá∫Âæ™ÁéØ
                end
            end
        end)

    else
        print("[AutoRetry] Ëá™Âä®ÂâØÊú¨ÈáçËØïÂ∑≤ÂÖ≥Èó≠")
    end
end):Set(Settings.AutoDungeonRetry or false)

--================= Ëá™Âä®‰º†ÈÄÅ‰∏éÂÆùÁÆ±ÂºÄÂÖ≥ =================--
features:AddSwitch("Ëá™Âä®‰º†ÈÄÅ & ÂºÄÂÆùÁÆ±", function(state)
    Settings.AutoTeleportChests = state
    SaveSettings()

    if state then
        --================= ÂàùÂßãÂåñ =================--
        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")

        local player = Players.LocalPlayer

        local ignoredModels = {
            ["84f0df6486bd4efa"] = true,
        }

        local teleportDelay = 3 -- Áßí
        local openedChests = {} -- Â∑≤ÂºÄÂêØÂÆùÁÆ±ËÆ∞ÂΩï

        --================= Â∑•ÂÖ∑ÂáΩÊï∞ =================--

        local function hasBoss()
            for _, room in ipairs(Workspace:GetChildren()) do
                if room:IsA("Model") and (room:FindFirstChild("EnemySpawnPoint") or room:FindFirstChild("EnemySpawnArea")) then
                    for _, obj in ipairs(room:GetChildren()) do
                        if obj:IsA("Model") and obj:FindFirstChild("HumanoidRootPart") and not ignoredModels[obj.Name] then
                            local typeAttr = obj:GetAttribute("Type")
                            local hasBossChild = obj:FindFirstChild("Boss") ~= nil
                            if (typeAttr and string.find(string.lower(typeAttr), "boss")) or hasBossChild then
                                return true
                            end
                        end
                    end
                end
            end
            return false
        end

        local function hasEnemy()
            for _, room in ipairs(Workspace:GetChildren()) do
                if room:IsA("Model") and (room:FindFirstChild("EnemySpawnPoint") or room:FindFirstChild("EnemySpawnArea")) then
                    for _, obj in ipairs(room:GetChildren()) do
                        if obj:IsA("Model") and obj:FindFirstChild("HumanoidRootPart") and not ignoredModels[obj.Name] then
                            return true
                        end
                    end
                end
            end
            return false
        end

        local function getClosestDoor()
            local closestDoor, shortestDist = nil, math.huge
            local playerPos = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position
            if not playerPos then return nil end

            for _, room in ipairs(Workspace:GetChildren()) do
                local door = room:FindFirstChild("Door")
                if door then
                    local doorPos
                    if door.PrimaryPart then
                        doorPos = door.PrimaryPart.Position
                    else
                        local success, pivot = pcall(function() return door:GetPivot().Position end)
                        if success then doorPos = pivot else
                            local part = door:FindFirstChildWhichIsA("BasePart")
                            if part then doorPos = part.Position end
                        end
                    end
                    if doorPos then
                        local dist = (doorPos - playerPos).Magnitude
                        if dist < shortestDist then
                            shortestDist, closestDoor = dist, door
                        end
                    end
                end
            end
            return closestDoor
        end

        local function getFurthestDoorInRoom(room)
            if not room then return nil end
            local furthestDoor, maxDist = nil, -math.huge
            local playerPos = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position
            if not playerPos then return nil end

            for _, door in ipairs(room:GetChildren()) do
                if door:IsA("Model") and string.find(door.Name, "Door") and door:FindFirstChild("Collider") then
                    local collider = door:FindFirstChild("Collider")
                    local dist = (collider.Position - playerPos).Magnitude
                    if dist > maxDist then
                        maxDist = dist
                        furthestDoor = door
                    end
                end
            end
            return furthestDoor
        end

        local function teleportToDoorCollider(door)
            if not door or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
            local collider = door:FindFirstChild("Collider")
            if not collider then
                print("[TeleportTest] Door Ê≤°Êúâ Collider:", door.Name)
                return
            end
            player.Character.HumanoidRootPart.CFrame = CFrame.new(collider.Position + Vector3.new(0,3,0))
            print("[TeleportTest] Â∑≤‰º†ÈÄÅÂà∞ÁõÆÂΩï:", door.Parent.Name, "Door:", door.Name, "Collider Pos:", collider.Position)
        end

        --================= ÂÆùÁÆ±Áõ∏ÂÖ≥ =================--

        local function getChestsInRoom(room)
            local chests = {}
            for _, obj in ipairs(room:GetChildren()) do
                if obj:IsA("Model") and string.find(obj.Name, "DungeonChest") then
                    if not openedChests[obj] then
                        table.insert(chests, obj)
                    end
                end
            end
            return chests
        end

        local function openChest(chest)
            if not chest or not chest:IsDescendantOf(workspace) then return end
            local prompt = chest:FindFirstChild("ProximityPrompt", true)
            if not prompt then return end

            local chestPos = chest.PrimaryPart and chest.PrimaryPart.Position or chest:GetPivot().Position
            player.Character.HumanoidRootPart.CFrame = CFrame.new(chestPos + Vector3.new(0,3,0))
            task.wait(1)
            prompt:InputHoldBegin()
            task.wait(1)
            prompt:InputHoldEnd()
            
            print("[Chest] Â∑≤ÊâìÂºÄÂÆùÁÆ±:", chest.Name)
            openedChests[chest] = true
            task.wait(0.5)
        end

        --================= ‰∏ªÂæ™ÁéØ =================--

        task.spawn(function()
            while Settings.AutoTeleportChests do -- ‚úÖ Ê£ÄÊü•ÂºÄÂÖ≥Áä∂ÊÄÅ
                task.wait(1)
                if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then continue end

                if hasBoss() then
                    print("[AutoTest] Ê£ÄÊµãÂà∞ BossÔºåÂÅúÊ≠¢‰º†ÈÄÅËÑöÊú¨")
                    break
                end

                if hasEnemy() then
                    print("[AutoTest] Âú∫ÊôØ‰∏≠Â≠òÂú®Êïå‰∫∫ÔºåÊöÇÂÅú‰º†ÈÄÅ")
                    task.wait(1)
                else
                    local closestDoor = getClosestDoor()
                    if closestDoor and closestDoor.Parent then
                        local room = closestDoor.Parent
                        -- ÂÖàËÆ∞ÂΩïÊúÄËøúÈó® Collider
                        local furthestDoor = getFurthestDoorInRoom(room)
                        local furthestColliderPos = furthestDoor and furthestDoor:FindFirstChild("Collider") and furthestDoor.Collider.Position or nil

                        -- Êâ´ÊèèÂÆùÁÆ±
                        local chests = getChestsInRoom(room)
                        if #chests > 0 then
                            table.sort(chests, function(a, b)
                                local pa = a.PrimaryPart and a.PrimaryPart.Position or a:GetPivot().Position
                                local pb = b.PrimaryPart and b.PrimaryPart.Position or b:GetPivot().Position
                                local playerPos = player.Character.HumanoidRootPart.Position
                                return (pa - playerPos).Magnitude < (pb - playerPos).Magnitude
                            end)
                            for _, chest in ipairs(chests) do
                                openChest(chest)
                            end
                        end

                        -- ÂÆùÁÆ±ÂºÄÂÆåÂêéÔºå‰º†ÈÄÅÂà∞ÊúÄËøúÈó® Collider
                        if furthestColliderPos then
                            player.Character.HumanoidRootPart.CFrame = CFrame.new(furthestColliderPos + Vector3.new(0,3,0))
                            print("[TeleportTest] ÂÆùÁÆ±Â§ÑÁêÜÂÆåÊØïÔºå‰º†ÈÄÅÂà∞ÊúÄËøúÈó® Collider:", furthestDoor.Name, "Pos:", furthestColliderPos)
                            task.wait(teleportDelay)
                        end
                    end
                end
            end
            print("[AutoTeleport] Âæ™ÁéØÁªìÊùü")
        end)

    else
        print("[AutoTeleport] Ëá™Âä®‰º†ÈÄÅ‰∏éÂÆùÁÆ±Â∑≤ÂÖ≥Èó≠")
    end
end):Set(Settings.AutoTeleportChests or false)


-- Ëá™Âä®ÂêÉË°ÄËçØÂºÄÂÖ≥
local autoPotionSwitch = features:AddSwitch('Ëá™Âä®ÂêÉË°ÄËçØ', function(bool)
    Settings.HealthMonitorEnabled = bool
    SaveSettings()
end)
if autoPotionSwitch.Set then autoPotionSwitch:Set(Settings.HealthMonitorEnabled) end
-- Ëé∑ÂèñÁé©ÂÆ∂

-- ÂàõÂª∫ÂºÄÂÖ≥
local autodisable = features:AddSwitch('ÂÖ≥Èó≠ÈÄâÊã©ÂíåÊñΩÊ≥ïÂä®Áîª', function(bool)
    Settings.DisableSkillAnimations = bool
    SaveSettings()

    -- Â¶ÇÊûúÂºÄÂÖ≥ÂºÄÂêØÔºåÂ∞±Á¶ÅÁî®Áõ∏ÂÖ≥ LocalScript/Script
    if bool then
        -- Á¶ÅÁî® GUI ÂÜÖÁöÑ LocalScript
        local endlessChooseScript = player.PlayerGui:FindFirstChild("Main") 
            and player.PlayerGui.Main:FindFirstChild("Func") 
            and player.PlayerGui.Main.Func:FindFirstChild("EndlessChoose") 
            and player.PlayerGui.Main.Func.EndlessChoose:FindFirstChild("EndlessChoose")
        if endlessChooseScript and endlessChooseScript:IsA("LocalScript") then
            endlessChooseScript.Disabled = true
        end

        -- Á¶ÅÁî® ReplicatedStorage ÁöÑ Script/LocalScript
        local clientRunTimeScript = game:GetService("ReplicatedStorage"):FindFirstChild("ClientBase")
            and game:GetService("ReplicatedStorage").ClientBase:FindFirstChild("Skill")
            and game:GetService("ReplicatedStorage").ClientBase.Skill:FindFirstChild("ClientRunTime")
        if clientRunTimeScript and (clientRunTimeScript:IsA("Script") or clientRunTimeScript:IsA("LocalScript")) then
            clientRunTimeScript.Disabled = true
        end
    end
end)

-- ËÆæÁΩÆÂºÄÂÖ≥ÂàùÂßãÁä∂ÊÄÅ
if autodisable.Set then
    autodisable:Set(Settings.DisableSkillAnimations)
end
-- ÊäÄËÉΩÂæ™ÁéØÈáäÊîæÂºÄÂÖ≥
local autoSkillSwitch = features:AddSwitch('ÊäÄËÉΩÂæ™ÁéØÈáäÊîæ', function(bool)
    Settings.AutoSkillEnabled = bool
    SaveSettings()
end)
if autoSkillSwitch.Set then autoSkillSwitch:Set(Settings.AutoSkillEnabled) end
-- edndlessÂæ™ÁéØÈáäÊîæÂºÄÂÖ≥
features:AddSwitch('Ëá™Âä®ÈÄâÊã© Endless', function(state)
    Settings.AutoEndlessChoose = state
    SaveSettings()

    -- Á°Æ‰øùÂè™Ê≥®ÂÜå‰∏ÄÊ¨°ÁõëÂê¨
    if not _G.AutoEndlessListenerRegistered then
        _G.AutoEndlessListenerRegistered = true

        -- ÂÖ®Â±ÄÊ≥®ÂÜåÁõëÂê¨
        TNet.SetEvent("Endless_ShowPlayerUpgrade", function(upgradeList)
            print("‚ö†Ô∏è Êî∂Âà∞ Endless_ShowPlayerUpgrade ‰∏ãÂèëÊï∞ÊçÆ:")
            for i, id in ipairs(upgradeList) do
                local upgradeInfo = Config.Endless.UpgradeList[id]
                local name = upgradeInfo and upgradeInfo.name or "Êú™Áü•"
                local desc = upgradeInfo and upgradeInfo.description or "Êó†ÊèèËø∞"
                print(string.format("Index[%d] -> ID: %d, ÂêçÁß∞: %s, ÊèèËø∞: %s", i, id, name, desc))
            end

            if Settings.AutoEndlessChoose then
                local chosenIndex = nil

                -- ‰ºòÂÖàÊâæÂêçÂ≠óÂåÖÂê´ CrystalÔºàÂøΩÁï•Â§ßÂ∞èÂÜôÔºâ
                for i, id in ipairs(upgradeList) do
                    local upgradeInfo = Config.Endless.UpgradeList[id]
                    if upgradeInfo and string.find(upgradeInfo.name:lower(), "crystal") then
                        chosenIndex = i
                        break
                    end
                end

                -- Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ CrystalÔºåÂàôÊâæ Chest
                if not chosenIndex then
                    for i, id in ipairs(upgradeList) do
                        local upgradeInfo = Config.Endless.UpgradeList[id]
                        if upgradeInfo and string.find(upgradeInfo.name:lower(), "chest") then
                            chosenIndex = i
                            break
                        end
                    end
                end

                -- Â¶ÇÊûúËøòÊòØÊ≤°ÊúâÊâæÂà∞ÔºåÂàôÊåâ ID ÊúÄÂêéÊï∞Â≠óÊúÄÂ§ß
                if not chosenIndex then
                    local maxLastDigit = -1
                    for i, id in ipairs(upgradeList) do
                        local lastDigit = tonumber(tostring(id):sub(-1)) or 0
                        if lastDigit > maxLastDigit then
                            maxLastDigit = lastDigit
                            chosenIndex = i
                        end
                    end
                end

                -- ÂèëÈÄÅÈÄâÊã©
                pcall(function()
                    print("[AutoEndless] Ëá™Âä®ÈÄâÊã© Index:", chosenIndex)
                    TNet.FireServer("Endless_PlayerChoose", chosenIndex)
                end)
            end
        end)
    end
end):Set(Settings.AutoEndlessChoose)




-- ÂõûÂêàÊ£ÄÊµãÂºÄÂÖ≥
local roundCheckSwitch = features:AddSwitch('ÂõûÂêàÊ£ÄÊü•', function(bool)
    Settings.RoundTeleportEnabled = bool
    SaveSettings()
end)
if roundCheckSwitch.Set then roundCheckSwitch:Set(Settings.RoundTeleportEnabled) end

--================= ÂõûÂêàÈòàÂÄº‰∏éÊòæÁ§∫ =================--
if type(Settings.RoundTeleportThreshold) ~= 'number' then
    Settings.RoundTeleportThreshold = 55
    SaveSettings()
end
local RoundThresholdValue = Settings.RoundTeleportThreshold
-- ÂõûÂêàÊòæÁ§∫Label
local roundLabel = features:AddLabel('ÂõûÂêà: 0 / ' .. RoundThresholdValue)

-- Âà∑Êñ∞ÂáΩÊï∞
local function UpdateRoundLabel(currentRound)
    currentRound = currentRound or 0
    roundLabel.Text = 'ÂõûÂêà: ' .. currentRound .. ' / ' .. RoundThresholdValue
end
-- Ê∑ªÂä†ÈòàÂÄºÊòæÁ§∫Êõ¥Êñ∞ÂáΩÊï∞
local function UpdateThresholdDisplay()
    RoundThresholdValue = Settings.RoundTeleportThreshold
    -- Êõ¥Êñ∞ÂõûÂêàÊòæÁ§∫ÁöÑÈòàÂÄºÈÉ®ÂàÜ
    local currentRound = tonumber(string.match(roundLabel.Text, 'ÂõûÂêà: (%d+)') or 0)
    roundLabel.Text = 'ÂõûÂêà: ' .. currentRound .. ' / ' .. RoundThresholdValue
    print('[DEBUG] ÈòàÂÄºÊõ¥Êñ∞‰∏∫:', RoundThresholdValue)
end
-- ËÆæÁΩÆÈÄÄÂá∫ÂõûÂêàÈòàÂÄºËæìÂÖ•Ê°Ü
local thresholdInput = features:AddTextBox('ËÆæÁΩÆÈÄÄÂá∫ÂõûÂêàÈòàÂÄº', function(text)
    local num = tonumber(text)
    if num and num > 0 then
        Settings.RoundTeleportThreshold = num
        SaveSettings()
        UpdateThresholdDisplay()
        print('[DEBUG] ÈòàÂÄºËÆæÁΩÆ‰∏∫:', num)
    else
        -- ËæìÂÖ•Êó†ÊïàÔºåÁõ¥Êé•‰øÆÊîπTextÂ±ûÊÄßÊÅ¢Â§çÂéüÂÄº
        thresholdInput.Text = tostring(Settings.RoundTeleportThreshold)
        print('[WARN] Êó†ÊïàËæìÂÖ•ÔºåÂ∑≤ÊÅ¢Â§ç‰∏∫:', Settings.RoundTeleportThreshold)
    end
end)
thresholdInput.Text = tostring(Settings.RoundTeleportThreshold)
print('[DEBUG] ËæìÂÖ•Ê°ÜÂàùÂßãÂÄºËÆæÁΩÆ‰∏∫:', Settings.RoundTeleportThreshold)
-- ‰∏ªÂæ™ÁéØÂà∑Êñ∞ÂõûÂêà Label
spawn(function()
    while true do
        task.wait(0.5)
        local currentRound = 0
        pcall(function()
            local roundGui = player.PlayerGui:FindFirstChild('Main')
                and player.PlayerGui.Main:FindFirstChild('HomePage')
                and player.PlayerGui.Main.HomePage:FindFirstChild('EndlessTop')
                and player.PlayerGui.Main.HomePage.EndlessTop:FindFirstChild('Top')
                and player.PlayerGui.Main.HomePage.EndlessTop.Top:FindFirstChild('RoundTitle')
            if roundGui then
                currentRound = tonumber(string.match(roundGui.Text, '%d+')) or 0
            end
        end)
        UpdateRoundLabel(currentRound)
    end
end)


--================= Ëá™Âä®ËøõÂÖ•ÂâØÊú¨Âæ™ÁéØ =================--
spawn(function()
    while true do
        task.wait(5)
        if not Settings.AutoDungeonEnabled then continue end
        if Workspace:FindFirstChild('Lobby') then
            local sel = Settings.SelectedDungeon or '1-1'
            local dungeonId, difficulty = unpack(DungeonMap[sel] or DungeonMap['1-1'])
            print('[DEBUG] Â∞ùËØïËøõÂÖ•ÂâØÊú¨:', sel)
            pcall(function() EnterDungeon(dungeonId, difficulty) end)
        end
    end
end)

--================= ÂâØÊú¨ÂÜÖÁõëÊéß ===================
function SetupInDungeon()
    spawn(function()
        -- Á≠âÂæÖ _G.KillauraKey ÊçïËé∑
        while not _G.KillauraKey do
            print("[SetupInDungeon] Á≠âÂæÖ _G.KillauraKey ÊçïËé∑‰∏≠...")
            task.wait(1)
        end
        print("[SetupInDungeon] Â∑≤ÊçïËé∑Âà∞ Key:", _G.KillauraKey)

        -- Â¶ÇÊûúÂú®Â§ßÂéÖÔºåÁõ¥Êé•ËøîÂõû
        if Workspace:FindFirstChild('Lobby') then return end

        local healthPath, roundPath

        -- Â∞ùËØïËé∑ÂèñË°ÄÈáèÂíåÂõûÂêà UI
        local success, mainGui = pcall(function()
            return player:WaitForChild('PlayerGui'):WaitForChild('Main', 5)
        end)
        if success and mainGui then
            local home = mainGui:FindFirstChild('HomePage')
            if home then
                -- Ë°ÄÈáèË∑ØÂæÑ
                local bottom = home:FindFirstChild('Bottom')
                if bottom then
                    local mainBottom = bottom:FindFirstChild('Main')
                    if mainBottom then
                        local health = mainBottom:FindFirstChild('Health')
                        if health then
                            local num = health:FindFirstChild('Num')
                            if num then
                                healthPath = num:FindFirstChild('Health')
                            end
                        end
                    end
                end

                -- ÂõûÂêàË∑ØÂæÑ
                local endlessTop = home:FindFirstChild('EndlessTop')
                if endlessTop then
                    local top = endlessTop:FindFirstChild('Top')
                    if top then
                        roundPath = top:FindFirstChild('RoundTitle')
                    end
                end
            end
        end

        -- Ëá™Âä®ÂêÉË°ÄËçØ
        if healthPath then
            local onCooldown = false
            healthPath:GetPropertyChangedSignal('Text'):Connect(function()
                if not Settings.HealthMonitorEnabled then return end
                local cur, max = string.match(healthPath.Text, '(%d+)%/(%d+)')
                if cur and max then
                    cur, max = tonumber(cur), tonumber(max)
                    if max > 0 and cur/max < 0.63 and not onCooldown then
                        onCooldown = true
                        pcall(function() TNet.FireServer('Potion_TryHealth') end)
                        task.delay(2, function() onCooldown = false end)
                    end
                end
            end)
        end

        -- ÂõûÂêàÁõëÊéß
        if roundPath then
            roundPath:GetPropertyChangedSignal('Text'):Connect(function()
                local roundNum = tonumber(string.match(roundPath.Text, '%d+')) or 0
                UpdateRoundLabel(roundNum)
                if Settings.RoundTeleportEnabled and roundNum >= RoundThresholdValue then
                    print('[DEBUG] ËææÂà∞ÂõûÂêàÈòàÂÄºÔºåÈÄÄÂá∫ÂâØÊú¨')
                    pcall(function()
                        TNet.FireServer('Dungeon_Leave')
                        task.wait(1)
                        TeleportService:Teleport(72607172956362)
                    end)
                end
            end)
        end

        -- ÊäÄËÉΩÂæ™ÁéØÈáäÊîæ
        if Settings.AutoSkillEnabled then
            spawn(function()
                while Settings.AutoSkillEnabled do
                    if player.Character and player.PlayerGui and not Workspace:FindFirstChild("Lobby") then
                        for spell = 1, 5 do
                            pcall(function() 
                                TNet.FireServer("Skill_Release", spell) 
                            end)
                            task.wait(0.08)
                        end
                    end
                    task.wait(0.1)
                end
            end)
        end
    end)
end

-- ÂáÜÂ§áÂ•ΩÁé©ÂÆ∂‰ª•ÂêéÂÜçÊâßË°å
spawn(function()
    SetupInDungeon()
end)


--================= ÈÄÄÂá∫ÂâØÊú¨ÊåâÈíÆ =================--
features:AddButton('ÈÄÄÂá∫ÂâØÊú¨', function()
    pcall(function() TeleportService:Teleport(72607172956362) end)
end)

features1:AddButton('ÈôÑÈ≠îÂ∑•ÂÖ∑', function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/supleruckydior/test/refs/heads/main/dungeon/ÈôÑÈ≠îÂ∑•ÂÖ∑"))()
end)
features1:AddLabel('Ë£ÖÂ§áÂá∫ÂîÆÊï∞Èáè‰∏∫1000')
-- ÊåâÈíÆÂäüËÉΩÔºöÊâπÈáèÂèëÈÄÅÁ®ÄÊúâÂ∫¶‰∏∫1ÁöÑË£ÖÂ§á ref
features1:AddButton("Âá∫ÂîÆÁôΩËâ≤Ë£ÖÂ§á", function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local EquipmentShare = require(ReplicatedStorage.ClientBase.EquipmentShare)
    local items = (EquipmentShare.Data and EquipmentShare.Data.Bag and EquipmentShare.Data.Bag.Items) or {}
    local refsToSend = {}

    for _, item in ipairs(items) do
        local idStr = item and item.id and tostring(item.id)
        if idStr and #idStr >= 3 and tonumber(idStr:sub(3,3)) == 1 then
            table.insert(refsToSend, item.ref)
        end
    end

    if #refsToSend > 0 then
        local batchRefs = {}
        for i = 1, math.min(1000, #refsToSend) do
            table.insert(batchRefs, refsToSend[i])
        end

        pcall(function()
            TNet.FireServer("Equipment_Sell", batchRefs)
        end)

        print("Â∑≤ÊâπÈáèÂèëÈÄÅ " .. #batchRefs .. " ‰∏™Á®ÄÊúâÂ∫¶1Ë£ÖÂ§áÁöÑ ref")
    else
        warn("Êú™ÊâæÂà∞Á®ÄÊúâÂ∫¶‰∏∫1ÁöÑË£ÖÂ§á")
    end
end)

features1:AddButton("Âá∫ÂîÆÁªøËâ≤Ë£ÖÂ§á", function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local EquipmentShare = require(ReplicatedStorage.ClientBase.EquipmentShare)

    local items = (EquipmentShare.Data and EquipmentShare.Data.Bag and EquipmentShare.Data.Bag.Items) or {}
    local refsToSend = {}

    for _, item in ipairs(items) do
        local idStr = item and item.id and tostring(item.id)
        if idStr and #idStr >= 3 and tonumber(idStr:sub(3,3)) == 2 then
            table.insert(refsToSend, item.ref)
        end
    end

    if #refsToSend > 0 then
        local batchRefs = {}
        for i = 1, math.min(1000, #refsToSend) do
            table.insert(batchRefs, refsToSend[i])
        end

        pcall(function()
            TNet.FireServer("Equipment_Sell", batchRefs)
        end)

        print("Â∑≤ÊâπÈáèÂèëÈÄÅ " .. #batchRefs .. " ‰∏™Á®ÄÊúâÂ∫¶2Ë£ÖÂ§áÁöÑ ref")
    else
        warn("Êú™ÊâæÂà∞Á®ÄÊúâÂ∫¶‰∏∫2ÁöÑË£ÖÂ§á")
    end
end)

features1:AddButton("Âá∫ÂîÆËìùËâ≤Ë£ÖÂ§á", function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local EquipmentShare = require(ReplicatedStorage.ClientBase.EquipmentShare)

    local items = (EquipmentShare.Data and EquipmentShare.Data.Bag and EquipmentShare.Data.Bag.Items) or {}
    local refsToSend = {}

    for _, item in ipairs(items) do
        local idStr = item and item.id and tostring(item.id)
        if idStr and #idStr >= 3 and tonumber(idStr:sub(3,3)) == 3 then
            table.insert(refsToSend, item.ref)
        end
    end

    if #refsToSend > 0 then
        local batchRefs = {}
        for i = 1, math.min(1000, #refsToSend) do
            table.insert(batchRefs, refsToSend[i])
        end

        pcall(function()
                                TNet.FireServer("Equipment_Sell", batchRefs)
        end)

        print("Â∑≤ÊâπÈáèÂèëÈÄÅ " .. #batchRefs .. " ‰∏™Á®ÄÊúâÂ∫¶3Ë£ÖÂ§áÁöÑ ref")
    else
        warn("Êú™ÊâæÂà∞Á®ÄÊúâÂ∫¶‰∏∫3ÁöÑË£ÖÂ§á")
    end
end)
features1:AddButton("Âá∫ÂîÆÁ¥´Ëâ≤‰ª•‰∏ãÂÖ®ÈÉ®", function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local EquipmentShare = require(ReplicatedStorage.ClientBase.EquipmentShare)

    local items = (EquipmentShare.Data and EquipmentShare.Data.Bag and EquipmentShare.Data.Bag.Items) or {}
    local refsToSend = {}

    for _, item in ipairs(items) do
        local idStr = item and item.id and tostring(item.id)
        if idStr and #idStr >= 3 and tonumber(idStr:sub(3,3)) <= 3 then
            table.insert(refsToSend, item.ref)
        end
    end

    if #refsToSend > 0 then
        local batchRefs = {}
        for i = 1, math.min(1000, #refsToSend) do
            table.insert(batchRefs, refsToSend[i])
        end

        pcall(function()
                                TNet.FireServer("Equipment_Sell", batchRefs)
        end)

        print("Â∑≤ÊâπÈáèÂèëÈÄÅ " .. #batchRefs .. " ‰∏™Á®ÄÊúâÂ∫¶Â∞è‰∫é4Ë£ÖÂ§áÁöÑ ref")
    else
        warn("Êú™ÊâæÂà∞Á®ÄÊúâÂ∫¶Â∞è‰∫é4ÁöÑË£ÖÂ§á")
    end
end)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local EquipmentShare = require(ReplicatedStorage.ClientBase.EquipmentShare)
features1:AddLabel('Ê≥®ÊÑèdupe‰ºöÊ∏ÖÁ©∫ËÉåÂåÖÈáåÊâÄÊúâÁâ©ÂìÅÔºåË¶Å‰øùÁïôÁöÑ‰∏úË•øËÆ∞ÂæóÊîæÂú®‰∫åÊ•º‰ªìÂ∫ìÈáå')
features1:AddSwitch("dupe", function(state)
    if state then
        print("[Loop] Âæ™ÁéØÂºÄÂßã")
        if not _G.PacketLoop then
            _G.PacketLoopRunning = true
            _G.PacketLoop = task.spawn(function()
                while _G.PacketLoopRunning do
                    
                    -- ÂÖàÂèë y 100 Ê¨°
                    for i = 1, 100 do
                        if not _G.PacketLoopRunning then break end
                        pcall(function()
                            TNetSent:FireServer("y", 100)
                        end)
                        task.wait(0.02)
                    end
                    if not _G.PacketLoopRunning then break end

                    -- ÁÑ∂ÂêéÂèë‰∏ÄÊ¨° Backpack_EquipBest
                    pcall(function()
                        TNet.FireServer("Backpack_EquipBest")
                    end)
                    task.wait(0.1)

                    -- Â¶ÇÊûúËÉåÂåÖË∂ÖËøá700‰∏™Áâ©ÂìÅÔºåÊâßË°åÂá∫ÂîÆ
                    local items = (EquipmentShare.Data and EquipmentShare.Data.Bag and EquipmentShare.Data.Bag.Items) or {}
                    if #items > 700 then
                        for _, item in ipairs(items) do
                            if not _G.PacketLoopRunning then break end
                            local refToSend = item.ref or 1052
                            pcall(function()
                                TNet.FireServer("Equipment_Sell", { refToSend })
                            end)
                        end
                    end
                end
                _G.PacketLoop = nil
                print("[Loop] Â∑≤ÁªìÊùü")
            end)
        end
    else
        print("[Loop] Âæ™ÁéØÂ∑≤ÂÖ≥Èó≠")
        _G.PacketLoopRunning = false
        _G.PacketLoop = nil
    end
end)

