if not game:IsLoaded() then
    game.Loaded:Wait()
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")

local LocalPlayer = Players.LocalPlayer

-- 检查GUI可见性（需要在MoveToTarget之前定义）
local function CheckGUIVisibility()
    local success, result = pcall(function()
        return game:GetService("Players").LocalPlayer.PlayerGui.GUI["\228\186\140\231\186\167\231\149\140\233\157\162"]["\229\177\149\231\164\186\229\165\150\229\138\177\231\149\140\233\157\162"].Visible
    end)
    if not success then
        -- GUI路径不存在，返回false（不shutdown）
        return false
    end
    return result == true
end

-- 初始等待期间也要检查GUI（使用Heartbeat每帧检查）
local initGuiCheckConnection
initGuiCheckConnection = RunService.Heartbeat:Connect(function()
    if CheckGUIVisibility() then
        if initGuiCheckConnection then
            initGuiCheckConnection:Disconnect()
        end
        print("初始化等待期间检测到GUI可见 - 关闭游戏")
        game:Shutdown()
    end
end)

local initStartTime = tick()
while tick() - initStartTime < 2 do
    wait(0.1)
end

if initGuiCheckConnection then
    initGuiCheckConnection:Disconnect()
end

-- 再次检查GUI（防止在断开连接后GUI才变为可见）
if CheckGUIVisibility() then
    print("初始化后检测到GUI可见 - 关闭游戏")
    game:Shutdown()
    return
end

-- 等待角色加载
local Character = LocalPlayer.Character
if not Character then
    Character = LocalPlayer.CharacterAdded:Wait()
end

local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Humanoid = Character:WaitForChild("Humanoid")
Humanoid.PlatformStand = false
-- 增加移动速度
Humanoid.WalkSpeed = 64

-- 检查水晶是否存在
local function CheckCrystalExists()
    return pcall(function()
        local crystals = workspace["\229\141\149\228\189\141\229\175\185\232\177\161"]:GetChildren()
        return #crystals > 0
    end)
end

-- 缓存的可用水晶
local cachedCrystal = nil

-- 查找可用的水晶（能成功计算路径的水晶）
local function FindAvailableCrystal()
    -- 如果已缓存的水晶仍然有效，直接返回
    if cachedCrystal and cachedCrystal.Parent then
        return cachedCrystal
    end
    
    local success, crystalContainer = pcall(function()
        return workspace["\229\141\149\228\189\141\229\175\185\232\177\161"]
    end)
    
    if not success or not crystalContainer then
        return nil
    end
    
    local crystals = crystalContainer:GetChildren()
    if #crystals == 0 then
        return nil
    end
    
    -- 获取当前角色位置
    local currentChar = LocalPlayer.Character
    if not currentChar or not currentChar.Parent then
        return nil
    end
    local currentHRP = currentChar:FindFirstChild("HumanoidRootPart")
    if not currentHRP then
        return nil
    end
    local startPos = currentHRP.Position
    
    -- 尝试每个水晶，找到第一个可以计算路径的
    for _, crystal in ipairs(crystals) do
        if crystal and crystal.Parent then
            -- 获取水晶位置
            local targetPosition
            if crystal:IsA("Model") then
                local pivotCFrame = crystal:GetPivot()
                targetPosition = pivotCFrame.Position
            elseif crystal:IsA("BasePart") then
                targetPosition = crystal.Position
            end
            
            -- 如果成功获取位置，尝试计算路径
            if targetPosition then
                -- 尝试计算路径
                local testPath = PathfindingService:CreatePath({
                    AgentRadius = 1,
                    AgentHeight = 3,
                    AgentCanJump = true,
                    WaypointSpacing = 4,
                })
                
                local pathFound, pathError = pcall(function()
                    testPath:ComputeAsync(startPos, targetPosition)
                end)
                
                if pathFound and testPath.Status ~= Enum.PathStatus.NoPath then
                    local waypoints = testPath:GetWaypoints()
                    if #waypoints > 0 then
                        -- 找到可用的水晶，缓存并返回
                        cachedCrystal = crystal
                        print("找到可用的水晶:", crystal.Name)
                        return crystal
                    end
                end
            end
        end
    end
    
    -- 如果所有水晶都无法计算路径，返回第一个水晶（作为备选）
    if #crystals > 0 then
        cachedCrystal = crystals[1]
        print("使用第一个水晶作为备选:", crystals[1].Name)
        return crystals[1]
    end
    
    return nil
end

-- 函数：在目标位置周围搜索可到达的点
local function findReachablePosition(targetPos, startPos, maxRadius)
    local searchRadius = maxRadius or 20  -- 默认20，可以传入更大的值
    local searchHeightRange = 50
    local searchStep = 5  -- 可以增加到10以加快搜索，但会降低精度
    
    for heightOffset = -searchHeightRange, searchHeightRange, 10 do
        for radius = 0, searchRadius, searchStep do
            for angle = 0, 360, 45 do
                local rad = math.rad(angle)
                local offsetX = math.cos(rad) * radius
                local offsetZ = math.sin(rad) * radius
                
                local testPos = Vector3.new(
                    targetPos.X + offsetX,
                    targetPos.Y + heightOffset,
                    targetPos.Z + offsetZ
                )
                
                local testPath = PathfindingService:CreatePath({
                    AgentRadius = 1,
                    AgentHeight = 3,
                    AgentCanJump = true,
                    WaypointSpacing = 4,  -- 使用较小的默认间距以获得更好的路径
                })
                
                local success, err = pcall(function()
                    testPath:ComputeAsync(startPos, testPos)
                end)
                
                if success then
                    local status = testPath.Status
                    if status == Enum.PathStatus.Success or 
                       status == Enum.PathStatus.ClosestNoPath or
                       status == Enum.PathStatus.ClosestOutOfRange then
                        local waypoints = testPath:GetWaypoints()
                        if #waypoints > 0 then
                            return testPos, testPath
                        end
                    end
                end
            end
        end
    end
    
    return nil, nil
end

-- 路径寻找函数
local function MoveToTarget(targetModel)
    if not targetModel then
        print("MoveToTarget: targetModel为空")
        return false
    end
    
    -- 确保角色仍然有效
    local currentChar = LocalPlayer.Character
    if not currentChar or not currentChar.Parent then
        print("MoveToTarget: 角色无效")
        return false
    end
    
    local currentHRP = currentChar:FindFirstChild("HumanoidRootPart")
    local currentHumanoid = currentChar:FindFirstChild("Humanoid")
    if not currentHRP or not currentHumanoid then
        print("MoveToTarget: 角色组件缺失")
        return false
    end
    
    -- 确保移动速度为高速
    currentHumanoid.WalkSpeed = 64
    
    -- 获取目标位置
    local targetPosition
    if targetModel:IsA("Model") then
        local pivotCFrame = targetModel:GetPivot()
        targetPosition = pivotCFrame.Position
    elseif targetModel:IsA("BasePart") then
        targetPosition = targetModel.Position
    else
        print("MoveToTarget: 目标类型不支持")
        return false
    end
    
    print("目标位置:", targetPosition)
    
    local startPos = currentHRP.Position
    -- 直接使用水晶位置作为目标，PathfindingService会自动找到最接近的可到达位置
    local endPos = targetPosition
    
    -- 检查距离
    local distance = (startPos - endPos).Magnitude
    print("起点到终点的距离:", distance)
    
    -- 使用默认的最佳间距（先尝试较小值以获得更精确的路径）
    local waypointSpacing = 4  -- 默认使用较小的间距以获得最佳路径
    
    -- 创建路径对象
    local path = PathfindingService:CreatePath({
        AgentRadius = 1,
        AgentHeight = 3,
        AgentCanJump = true,
        WaypointSpacing = waypointSpacing,
        Costs = {
            Water = 1,
        }
    })
    
    -- 计算路径
    print("开始计算路径，起始位置:", startPos, "目标位置:", endPos, "路径点间距:", waypointSpacing)
    local pathFound, noPathMessage = pcall(function()
        path:ComputeAsync(startPos, endPos)
    end)
    
    if not pathFound then
        local errorMsg = tostring(noPathMessage)
        print("路径计算异常:", errorMsg)
        
        -- 检查是否是"path request is too long"错误
        if string.find(errorMsg:lower(), "too long") or string.find(errorMsg:lower(), "path.*long") then
            print("检测到路径请求过长错误，尝试使用更大的路径点间距...")
            -- 尝试逐步增大WaypointSpacing
            local spacingOptions = {8, 12, 16, 20, 25, 30}
            local success = false
            
            for _, spacing in ipairs(spacingOptions) do
                print("尝试使用路径点间距:", spacing)
                local longerPath = PathfindingService:CreatePath({
                    AgentRadius = 1,
                    AgentHeight = 3,
                    AgentCanJump = true,
                    WaypointSpacing = spacing,
                    Costs = { Water = 1 }
                })
                local retrySuccess, retryError = pcall(function()
                    longerPath:ComputeAsync(startPos, endPos)
                end)
                if retrySuccess and longerPath.Status ~= Enum.PathStatus.NoPath then
                    path = longerPath
                    pathFound = true
                    success = true
                    print("使用路径点间距 " .. spacing .. " 成功计算路径")
                    break
                end
            end
            
            if not success then
                print("即使使用更大的路径点间距仍然失败，尝试在周围搜索可到达的点...")
                local reachablePos, reachablePath = findReachablePosition(endPos, startPos)
                if reachablePos and reachablePath then
                    endPos = reachablePos
                    path = reachablePath
                    pathFound = true
                    print("找到可到达的替代位置")
                else
                    print("无法找到任何可到达的路径")
                    return false
                end
            end
        else
            print("尝试在周围搜索可到达的点...")
            local reachablePos, reachablePath = findReachablePosition(endPos, startPos)
            if reachablePos and reachablePath then
                endPos = reachablePos
                path = reachablePath
                pathFound = true
                print("找到可到达的替代位置")
            else
                print("无法找到任何可到达的路径")
                return false
            end
        end
    end
    
    local pathStatus = path.Status
    print("路径状态:", pathStatus)
    
    -- 接受Success、ClosestNoPath和ClosestOutOfRange状态（这些都能到达接近目标的位置）
    if pathStatus == Enum.PathStatus.NoPath then
        print("无法找到路径，尝试在周围搜索...")
        local reachablePos, reachablePath = findReachablePosition(endPos, startPos)
        if reachablePos and reachablePath then
            endPos = reachablePos
            path = reachablePath
            pathStatus = reachablePath.Status
            print("找到可到达的替代位置")
        else
            print("无法找到任何可到达的路径")
            return false
        end
    elseif pathStatus == Enum.PathStatus.ClosestNoPath or pathStatus == Enum.PathStatus.ClosestOutOfRange then
        print("路径状态为", pathStatus, "- 将到达最接近目标的位置")
    end
    
    -- 获取路径点
    local waypoints = path:GetWaypoints()
    print("路径点数量:", #waypoints)
    if #waypoints == 0 then
        print("路径点为空")
        return false
    end
    
    -- 跳过第一个路径点（起始位置）
    local currentWaypointIndex = 1
    if #waypoints > 1 then
        currentWaypointIndex = 2
    end
    
    local isMoving = false
    local stuckCheckTime = 0
    local lastPosition = currentHRP.Position
    local moveComplete = false
    local moveConnection
    local lastCheckPosition = currentHRP.Position  -- 用于死亡检测
    local lastCheckTime = tick()  -- 用于死亡检测
    local isRecalculating = false  -- 防止重复重新计算
    local moveStartTimeTable = {value = nil}  -- 用于存储移动开始时间的引用，以便死亡时重置
    
    local function moveToNextWaypoint()
        -- 确保角色仍然有效（重新获取引用以确保最新）
        local currentChar = LocalPlayer.Character
        if not currentChar or not currentChar.Parent then
            print("移动中角色失效")
            moveComplete = true
            if moveConnection then
                moveConnection:Disconnect()
            end
            return false
        end
        
        local currentHRP = currentChar:FindFirstChild("HumanoidRootPart")
        local currentHumanoid = currentChar:FindFirstChild("Humanoid")
        
        if not currentHRP or not currentHumanoid then
            print("移动中角色组件缺失")
            moveComplete = true
            if moveConnection then
                moveConnection:Disconnect()
            end
            return false
        end
        
        if currentWaypointIndex > #waypoints then
            print("已到达所有路径点")
            moveComplete = true
            if moveConnection then
                moveConnection:Disconnect()
            end
            return false
        end
        
        local waypoint = waypoints[currentWaypointIndex]
        local targetPos = waypoint.Position
        
        print(string.format("移动到路径点 %d/%d: %s", currentWaypointIndex, #waypoints, tostring(targetPos)))
        
        -- 如果是跳跃点，设置跳跃
        if waypoint.Action == Enum.PathWaypointAction.Jump then
            currentHumanoid.Jump = true
        end
        
        -- 移动到目标位置
        -- 确保移动速度设置为高速
        if currentHumanoid.WalkSpeed < 64 then
            currentHumanoid.WalkSpeed = 64
        end
        currentHumanoid:MoveTo(targetPos)
        isMoving = true
        stuckCheckTime = tick()
        lastPosition = currentHRP.Position
        
        return true
    end
    
    -- 重新计算路径的函数（用于死亡后重新找路）
    local function recalculatePathForMove()
        print("重新计算路径...")
        task.wait(0.5)  -- 等待角色完全加载
        
        local currentChar = LocalPlayer.Character
        if not currentChar or not currentChar.Parent then
            return nil, nil
        end
        
        local currentHRP = currentChar:FindFirstChild("HumanoidRootPart")
        local currentHumanoid = currentChar:FindFirstChild("Humanoid")
        if not currentHRP or not currentHumanoid then
            return nil, nil
        end
        
        currentHumanoid.WalkSpeed = 64
        
        local newStartPos = currentHRP.Position
        print("新的起始位置:", newStartPos)
        
        local newDistance = (newStartPos - endPos).Magnitude
        local newWaypointSpacing = 4  -- 使用默认的最佳间距
        
        local newPath = PathfindingService:CreatePath({
            AgentRadius = 1,
            AgentHeight = 3,
            AgentCanJump = true,
            WaypointSpacing = newWaypointSpacing,
            Costs = { Water = 1 }
        })
        
        local pathFound, pathError = pcall(function()
            newPath:ComputeAsync(newStartPos, endPos)
        end)
        
        if not pathFound then
            local errorMsg = tostring(pathError)
            if string.find(errorMsg:lower(), "too long") or string.find(errorMsg:lower(), "path.*long") then
                -- 尝试逐步增大WaypointSpacing
                local spacingOptions = {8, 12, 16, 20, 25, 30}
                local success = false
                
                for _, spacing in ipairs(spacingOptions) do
                    local longerPath = PathfindingService:CreatePath({
                        AgentRadius = 1,
                        AgentHeight = 3,
                        AgentCanJump = true,
                        WaypointSpacing = spacing,
                        Costs = { Water = 1 }
                    })
                    local retrySuccess = pcall(function()
                        longerPath:ComputeAsync(newStartPos, endPos)
                    end)
                    if retrySuccess and longerPath.Status ~= Enum.PathStatus.NoPath then
                        newPath = longerPath
                        pathFound = true
                        success = true
                        break
                    end
                end
                
                if not success then
                    local reachablePos, reachablePath = findReachablePosition(endPos, newStartPos)
                    if reachablePos and reachablePath then
                        endPos = reachablePos
                        newPath = reachablePath
                        pathFound = true
                    else
                        return nil, nil
                    end
                end
            else
                local reachablePos, reachablePath = findReachablePosition(endPos, newStartPos)
                if reachablePos and reachablePath then
                    endPos = reachablePos
                    newPath = reachablePath
                    pathFound = true
                else
                    return nil, nil
                end
            end
        end
        
        local newPathStatus = newPath.Status
        if newPathStatus == Enum.PathStatus.NoPath then
            local reachablePos, reachablePath = findReachablePosition(endPos, newStartPos)
            if reachablePos and reachablePath then
                endPos = reachablePos
                newPath = reachablePath
                newPathStatus = reachablePath.Status
            else
                return nil, nil
            end
        end
        
        local newWaypoints = newPath:GetWaypoints()
        if #newWaypoints == 0 then
            return nil, nil
        end
        
        print("重新计算路径完成，共 " .. #newWaypoints .. " 个路径点")
        return newPath, newWaypoints
    end
    
    -- 创建移动循环
    moveConnection = RunService.Heartbeat:Connect(function()
        -- 检查GUI可见性（在移动循环中也要检查）
        if CheckGUIVisibility() then
            print("移动循环中检测到GUI可见 - 停止移动并关闭游戏")
            moveComplete = true
            if moveConnection then
                moveConnection:Disconnect()
            end
            game:Shutdown()
            return
        end
        
        -- 检查角色是否仍然有效（重新获取引用以确保最新）
        local currentChar = LocalPlayer.Character
        if not currentChar or not currentChar.Parent then
            print("移动循环中角色失效，停止移动")
            moveComplete = true
            if moveConnection then
                moveConnection:Disconnect()
            end
            return
        end
        
        local currentHRP = currentChar:FindFirstChild("HumanoidRootPart")
        if not currentHRP then
            return  -- 等待HumanoidRootPart加载
        end
        
        if moveComplete or currentWaypointIndex > #waypoints then
            if moveConnection then
                moveConnection:Disconnect()
            end
            return
        end
        
        local currentPos = currentHRP.Position
        local currentTime = tick()
        
        -- 死亡检测：如果位置突然发生大变化（超过100单位），说明角色死亡并重生
        -- 判断逻辑：每0.5秒检查一次位置变化，如果当前位置和上次记录位置的直线距离超过100单位，
        -- 说明角色可能已经死亡并重生到了新位置（通常在出生点），这时需要重新计算路径
        if currentTime - lastCheckTime > 0.5 and not isRecalculating then  -- 每0.5秒检查一次
            local positionChange = (currentPos - lastCheckPosition).Magnitude
            if positionChange > 60 then
                warn(string.format("检测到位置突然大变化 (%.1f 单位)，角色可能已死亡并重生，重新计算路径", positionChange))
                
                -- 重新计算路径
                isRecalculating = true
                local newPath, newWaypoints = recalculatePathForMove()
                if newPath and newWaypoints and #newWaypoints > 0 then
                    path = newPath
                    waypoints = newWaypoints
                    currentWaypointIndex = 1
                    if #waypoints > 1 then
                        currentWaypointIndex = 2
                    end
                    print("重新计算路径完成，共 " .. #waypoints .. " 个路径点，从路径点 " .. currentWaypointIndex .. " 开始")
                end
                isRecalculating = false
                
                -- 重置移动计时器（死亡后重新开始计时）
                if moveStartTimeTable.value then
                    moveStartTimeTable.value = tick()
                end
                
                -- 重置位置检查
                lastCheckPosition = currentPos
                lastCheckTime = currentTime
            else
                lastCheckPosition = currentPos
                lastCheckTime = currentTime
            end
        end
        
        -- 安全检查：确保路径点索引有效
        if currentWaypointIndex > #waypoints then
            moveComplete = true
            if moveConnection then
                moveConnection:Disconnect()
            end
            return
        end
        
        local waypoint = waypoints[currentWaypointIndex]
        local targetPos = waypoint.Position
        local distanceToWaypoint = (currentPos - targetPos).Magnitude
        
        -- 检查是否到达当前路径点（使用较小的判断距离以避免跳过路径点）
        if distanceToWaypoint < 6 then
            currentWaypointIndex = currentWaypointIndex + 1
            
            if currentWaypointIndex <= #waypoints then
                -- 立即切换到下一个路径点
                waypoint = waypoints[currentWaypointIndex]
                targetPos = waypoint.Position
                stuckCheckTime = tick()
                lastPosition = currentPos
                print(string.format("切换到路径点 %d/%d: %s", currentWaypointIndex, #waypoints, tostring(targetPos)))
            else
                print("已到达所有路径点")
                moveComplete = true
                if moveConnection then
                    moveConnection:Disconnect()
                end
                return
            end
        end
        
        -- 获取Humanoid以确保可以持续移动
        local currentHumanoid = currentChar:FindFirstChild("Humanoid")
        if currentHumanoid then
            -- 持续调用MoveTo确保角色一直移动（每帧都调用）
            if currentHumanoid.WalkSpeed < 64 then
                currentHumanoid.WalkSpeed = 64
            end
            -- 如果是跳跃点，设置跳跃
            if waypoint.Action == Enum.PathWaypointAction.Jump then
                currentHumanoid.Jump = true
            end
            currentHumanoid:MoveTo(targetPos)
            isMoving = true
        end
        
        -- 卡住检测（减少检测时间以提高响应速度）
        if isMoving and tick() - stuckCheckTime > 1.5 then
            local movedDistance = (currentPos - lastPosition).Magnitude
            if movedDistance < 2 then
                -- 卡住了，跳过当前路径点
                print(string.format("检测到卡住，跳过路径点 %d/%d", currentWaypointIndex, #waypoints))
                currentWaypointIndex = currentWaypointIndex + 1
                if currentWaypointIndex <= #waypoints then
                    stuckCheckTime = tick()
                    lastPosition = currentPos
                    waypoint = waypoints[currentWaypointIndex]
                    targetPos = waypoint.Position
                    print(string.format("跳过到路径点 %d/%d: %s", currentWaypointIndex, #waypoints, tostring(targetPos)))
                else
                    print("已到达所有路径点")
                    moveComplete = true
                    if moveConnection then
                        moveConnection:Disconnect()
                    end
                end
            else
                stuckCheckTime = tick()
                lastPosition = currentPos
            end
        end
    end)
    
        -- 开始移动
        print("开始移动到第一个路径点")
        if moveToNextWaypoint() then
            -- 等待移动完成（最多150秒）
            print("移动中，等待完成...")
            local MAX_MOVE_TIME = 150  -- 移动超时时间（秒）
            moveStartTimeTable.value = tick()  -- 设置移动开始时间，让Heartbeat回调可以重置
            
            -- 使用Heartbeat每帧检查GUI，确保第一时间退出
            local waitGuiCheckConnection
            waitGuiCheckConnection = RunService.Heartbeat:Connect(function()
                if CheckGUIVisibility() then
                    if waitGuiCheckConnection then
                        waitGuiCheckConnection:Disconnect()
                    end
                    print("等待移动完成时检测到GUI可见 - 停止移动并关闭游戏")
                    moveComplete = true
                    if moveConnection then
                        moveConnection:Disconnect()
                    end
                    game:Shutdown()
                end
            end)
            
            while not moveComplete and tick() - moveStartTimeTable.value < MAX_MOVE_TIME do
                wait(0.1)
                
                -- 检查角色是否仍然有效
                local currentChar = LocalPlayer.Character
                if not currentChar or not currentChar.Parent then
                    print("角色已消失，停止移动")
                    moveComplete = true
                    break
                end
            end
            
            if waitGuiCheckConnection then
                waitGuiCheckConnection:Disconnect()
            end
        if moveConnection then
            moveConnection:Disconnect()
        end
        if moveComplete then
            print("移动完成")
        else
            print("移动超时")
        end
        return moveComplete
    else
        print("无法开始移动")
    end
    
    if moveConnection then
        moveConnection:Disconnect()
    end
    return false
end

-- 执行路径寻找操作（替代原来的传送操作）
local function ExecutePathfindingOperation()
    -- 检查GUI可见性
    if CheckGUIVisibility() then
        print("执行路径寻找前检测到GUI可见 - 关闭游戏")
        game:Shutdown()
        return
    end
    
    -- 查找可用的水晶
    local targetModel = FindAvailableCrystal()
    
    if targetModel then
        print("找到目标水晶，开始路径寻找...")
        -- 如果移动失败（可能是死亡导致），重试一次
        local moveSuccess = MoveToTarget(targetModel)
        if not moveSuccess then
            -- 清除缓存，重新查找可用水晶
            cachedCrystal = nil
            
            -- 等待一下，可能是角色死亡需要重生（使用Heartbeat每帧检查GUI）
            local waitStartTime = tick()
            local retryGuiCheckConnection
            retryGuiCheckConnection = RunService.Heartbeat:Connect(function()
                if CheckGUIVisibility() then
                    if retryGuiCheckConnection then
                        retryGuiCheckConnection:Disconnect()
                    end
                    print("重试等待期间检测到GUI可见 - 关闭游戏")
                    game:Shutdown()
                end
            end)
            
            while tick() - waitStartTime < 2 do
                wait(0.1)
            end
            
            if retryGuiCheckConnection then
                retryGuiCheckConnection:Disconnect()
            end
            
            -- 再次检查GUI（防止在断开连接后GUI才变为可见）
            if CheckGUIVisibility() then
                print("重试前检测到GUI可见 - 关闭游戏")
                game:Shutdown()
                return
            end
            
            -- 重新查找可用水晶并重试
            local targetModel2 = FindAvailableCrystal()
            if targetModel2 then
                print("重试路径寻找...")
                moveSuccess = MoveToTarget(targetModel2)
            end
        end
        if moveSuccess then
            print("路径寻找完成")
        else
            print("路径寻找失败")
        end
    else
        print("未找到可用的水晶")
    end
end

-- 主循环
while true do
    -- 快速检查GUI可见性
    local guiVisible = CheckGUIVisibility()
    if guiVisible then
        print("检测到GUI可见 - 关闭游戏")
        game:Shutdown()
        return
    end
    
    -- 检查水晶是否存在
    local crystalSuccess, crystalExists = CheckCrystalExists()
    
    if crystalSuccess and crystalExists then
        -- 水晶存在时才检查GUI可见性
        if CheckGUIVisibility() then
            print("检测到GUI可见 - 关闭游戏")
            game:Shutdown()
            return
        end
        
        -- 执行路径寻找操作（替代传送）
        ExecutePathfindingOperation()
        
        -- 10秒冷却周期（持续检查GUI，使用Heartbeat每帧检查以确保第一时间退出）
        local startTime = tick()
        local guiCheckConnection
        guiCheckConnection = RunService.Heartbeat:Connect(function()
            if CheckGUIVisibility() then
                if guiCheckConnection then
                    guiCheckConnection:Disconnect()
                end
                print("冷却期间检测到GUI可见 - 关闭游戏")
                game:Shutdown()
            end
        end)
        
        -- 等待10秒或GUI可见（GUI检查由上面的Heartbeat处理）
        while tick() - startTime < 10 do
            wait(0.1)
        end
        
        if guiCheckConnection then
            guiCheckConnection:Disconnect()
        end
    else
        -- 水晶不存在时短暂等待（但仍持续检查GUI，使用Heartbeat每帧检查以确保第一时间退出）
        local startTime = tick()
        local guiCheckConnection
        guiCheckConnection = RunService.Heartbeat:Connect(function()
            if CheckGUIVisibility() then
                if guiCheckConnection then
                    guiCheckConnection:Disconnect()
                end
                print("等待期间检测到GUI可见 - 关闭游戏")
                game:Shutdown()
            end
        end)
        
        -- 等待1秒或GUI可见（GUI检查由上面的Heartbeat处理）
        while tick() - startTime < 1 do
            wait(0.1)
        end
        
        if guiCheckConnection then
            guiCheckConnection:Disconnect()
        end
    end
end
